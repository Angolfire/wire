{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wire \u00b6 \u201cA man got to have a code!\u201d - Omar Little As our teams and programs grow, the variety and volume of data also grows. Success will turn your simple data models into complex ones! Whether your application is storing data to disk or transmitting it over a network, the structure and interpretation of that data should be clear. Consumers work best with data they understand! Schemas describe and document data models. If you have data, you should have a schema. Protocol Buffers \u00b6 Google\u2019s Protocol Buffers are built around a great schema language: It\u2019s cross platform and language independent. Whatever programming language you use, you\u2019ll be able to use proto schemas with your application. Proto schemas are backwards-compatible and future-proof. You can evolve your schema as your application loses old features and gains new ones. It\u2019s focused. Proto schemas describe your data models. That\u2019s it. Here\u2019s a sample message definition: syntax = \"proto3\" ; package squareup . dinosaurs ; option java_package = \"com.squareup.dinosaurs\" ; import \"squareup/geology/period.proto\" ; message Dinosaur { // Common name of this dinosaur, like \"Stegosaurus\". string name = 1 ; // URLs with images of this dinosaur. repeated string picture_urls = 2 ; squareup.geology.Period period = 5 ; } And here\u2019s an enum definition: syntax = \"proto3\" ; package squareup . geology ; option java_package = \"com.squareup.geology\" ; enum Period { // 145.5 million years ago \u2014 66.0 million years ago. CRETACEOUS = 0 ; // 201.3 million years ago \u2014 145.0 million years ago. JURASSIC = 1 ; // 252.17 million years ago \u2014 201.3 million years ago. TRIASSIC = 2 ; } This schema language is Protocol Buffers\u2019 best feature. You might even use it purely for documentation purposes, such as to describe a JSON API. Protocol Buffers also defines a compact binary encoding of messages that conform to the schema. This encoding is fast to encode, fast to decode, small to transmit, and small to store. The binary encoding uses numeric tags from the schema, like the 5 for period above. For example, let\u2019s encode this dinosaur: { name: \"Stegosaurus\", period: JURASSIC } The encoded value is just 15 bytes: Hex Description 0a tag: name(1), field encoding: LENGTH_DELIMITED(2). 1 << 3 | 2 0b \"Stegosaurus\".length() 53 'S' 74 't' 65 'e' 67 'g' 6f 'o' 73 's' 61 'a' 75 'u' 72 'r' 75 'u' 73 's' 28 tag: period(5), field encoding: VARINT(0). 5 << 3 | 0 02 JURASSIC(2) Why Wire? \u00b6 The Protocol Buffers schema language and binary encoding are both defined by Google. Wire is an independent implementation from Square that\u2019s specifically designed for Android and Java. For each message type defined in the schema, Wire generates an immutable model class and its builder. The generated code looks like code you\u2019d write by hand: it\u2019s documented, formatted, and simple. Wire\u2019s APIs should feel at home to programmers who like Effective Java . That said, there are some interesting design decisions in Wire: Wire messages declare public final fields instead of the usual getter methods. This cuts down on both code generated and code executed. Less code is particularly beneficial for Android programs. Wire avoids case mapping. A field declared as picture_urls in a schema yields a Java field picture_urls and not the conventional pictureUrls camel case. Though the name feels awkward at first, it\u2019s fantastic whenever you use grep or more sophisticated search tools. No more mapping when navigating between schema, Java source code, and data. It also provides a gentle reminder to calling code that proto messages are a bit special. Primitive types are always boxed. If a field is absent, its value is null . This is used for naturally optional fields, such as a dinosaur whose period is unknown. A field may also be null due to schema evolution: if tomorrow we add a carnivore boolean to our message definition, today\u2019s data won\u2019t have a value for that field. Here\u2019s the compact generated code for the Dinosaur message defined above: // Code generated by Wire protocol buffer compiler, do not edit. // Source: squareup.dinosaurs.Dinosaur in squareup/dinosaurs/dinosaur.proto package com.squareup.dinosaurs ; import com.squareup.geology.Period ; import com.squareup.wire.Message ; import com.squareup.wire.ProtoAdapter ; import com.squareup.wire.Syntax ; import com.squareup.wire.WireField ; import com.squareup.wire.internal.Internal ; import java.lang.Object ; import java.lang.Override ; import java.lang.String ; import java.util.List ; import okio.ByteString ; public final class Dinosaur extends Message < Dinosaur , Dinosaur . Builder > { public static final ProtoAdapter < Dinosaur > ADAPTER = ProtoAdapter . newMessageAdapter ( Dinosaur . class , \"type.googleapis.com/squareup.dinosaurs.Dinosaur\" , Syntax . PROTO_3 ); private static final long serialVersionUID = 0 L ; /** * Common name of this dinosaur, like \"Stegosaurus\". */ @WireField ( tag = 1 , adapter = \"com.squareup.wire.ProtoAdapter#STRING\" , label = WireField . Label . OMIT_IDENTITY ) public final String name ; /** * URLs with images of this dinosaur. */ @WireField ( tag = 2 , adapter = \"com.squareup.wire.ProtoAdapter#STRING\" , label = WireField . Label . REPEATED , jsonName = \"pictureUrls\" ) public final List < String > picture_urls ; @WireField ( tag = 5 , adapter = \"com.squareup.geology.Period#ADAPTER\" , label = WireField . Label . OMIT_IDENTITY ) public final Period period ; public Dinosaur ( String name , List < String > picture_urls , Period period ) { this ( name , picture_urls , period , ByteString . EMPTY ); } public Dinosaur ( String name , List < String > picture_urls , Period period , ByteString unknownFields ) { super ( ADAPTER , unknownFields ); if ( name == null ) { throw new IllegalArgumentException ( \"name == null\" ); } this . name = name ; this . picture_urls = Internal . immutableCopyOf ( \"picture_urls\" , picture_urls ); if ( period == null ) { throw new IllegalArgumentException ( \"period == null\" ); } this . period = period ; } @Override public Builder newBuilder () { Builder builder = new Builder (); builder . name = name ; builder . picture_urls = Internal . copyOf ( picture_urls ); builder . period = period ; builder . addUnknownFields ( unknownFields ()); return builder ; } @Override public boolean equals ( Object other ) { if ( other == this ) return true ; if ( ! ( other instanceof Dinosaur )) return false ; Dinosaur o = ( Dinosaur ) other ; return unknownFields (). equals ( o . unknownFields ()) && Internal . equals ( name , o . name ) && picture_urls . equals ( o . picture_urls ) && Internal . equals ( period , o . period ); } @Override public int hashCode () { int result = super . hashCode ; if ( result == 0 ) { result = unknownFields (). hashCode (); result = result * 37 + ( name != null ? name . hashCode () : 0 ); result = result * 37 + picture_urls . hashCode (); result = result * 37 + ( period != null ? period . hashCode () : 0 ); super . hashCode = result ; } return result ; } public static final class Builder extends Message . Builder < Dinosaur , Builder > { public String name ; public List < String > picture_urls ; public Period period ; public Builder () { name = \"\" ; picture_urls = Internal . newMutableList (); period = Period . CRETACEOUS ; } /** * Common name of this dinosaur, like \"Stegosaurus\". */ public Builder name ( String name ) { this . name = name ; return this ; } /** * URLs with images of this dinosaur. */ public Builder picture_urls ( List < String > picture_urls ) { Internal . checkElementsNotNull ( picture_urls ); this . picture_urls = picture_urls ; return this ; } public Builder period ( Period period ) { this . period = period ; return this ; } @Override public Dinosaur build () { return new Dinosaur ( name , picture_urls , period , super . buildUnknownFields ()); } } } The Java code to create and access proto models is compact and readable: Dinosaur stegosaurus = new Dinosaur . Builder () . name ( \"Stegosaurus\" ) . period ( Period . JURASSIC ) . build (); System . out . println ( \"My favorite dinosaur existed in the \" + stegosaurus . period + \" period.\" ); Each type has a corresponding ProtoAdapter that can encode a message to bytes and decode bytes back into a message. Dinosaur stegosaurus = ... byte [] stegosaurusBytes = Dinosaur . ADAPTER . encode ( stegosaurus ); byte [] tyrannosaurusBytes = ... Dinosaur tyrannosaurus = Dinosaur . ADAPTER . decode ( tyrannosaurusBytes ); When accessing a field, use Wire.get() to replace null values with the corresponding default: Period period = Wire . get ( stegosaurus . period , Dinosaur . DEFAULT_PERIOD ); This is equivalent to the following: Period period = stegosaurus.period != null ? stegosaurus.period : Dinosaur.DEFAULT_PERIOD; Wire Kotlin \u00b6 Since version 3.0.0, Wire can generate Kotlin code. See Wire Compiler & Gradle Plugin to learn how to configure your build. Kotlin is a pragmatic and expressive programming language that makes it easy to model data. Here\u2019s how we used Kotlin to model Protocol Buffers messages: Messages feel like data classes, but in fact they\u2019re not. Compiler still generates equals() , hashCode() , toString() and copy() for you. Wire does not generate componentN() functions though, we believe that destructuring declarations are not a good fit for Protocol Buffers: a change in the schema that removes or adds a field might lead to a situation when your destructuring declaration still compiles but now describes a completely different subset of fields, rendering your code incorrect. copy() is a substitute for the Builder , which is not used anymore. If your program relies on the Builder to be present, you may generate code in Java interoperability mode - Wire Compiler & Gradle Plugin explains how that works. Fields are generated as properties. While this is idiomatic in Kotlin, Java code will now have to access fields using getters. If your program relies on accessing fields directly, use Java interoperability mode - the compiler will generate @JvmField annotations for each field. The nullability of each field\u2019s type depends on its label: required , repeated and map fields get non-nullable types, whereas optional fields are of nullable types. With the exception of required fields, each field has a default value: null for optional fields, emptyList() for repeated fields, emptyMap() for map fields. Here\u2019s the same Dinosaur message in Kotlin: // Code generated by Wire protocol buffer compiler, do not edit. // Source: squareup.dinosaurs.Dinosaur in squareup/dinosaurs/dinosaur.proto package com.squareup.dinosaurs import com.squareup.geology.Period import com.squareup.wire.FieldEncoding import com.squareup.wire.Message import com.squareup.wire.ProtoAdapter import com.squareup.wire.ProtoReader import com.squareup.wire.ProtoWriter import com.squareup.wire.Syntax.PROTO_3 import com.squareup.wire.WireField import com.squareup.wire.internal.immutableCopyOf import com.squareup.wire.internal.sanitize import kotlin.Any import kotlin.AssertionError import kotlin.Boolean import kotlin.Deprecated import kotlin.DeprecationLevel import kotlin.Int import kotlin.Long import kotlin.Nothing import kotlin.String import kotlin.collections.List import kotlin.hashCode import kotlin.jvm.JvmField import okio.ByteString class Dinosaur ( /** * Common name of this dinosaur, like \"Stegosaurus\". */ @field : WireField ( tag = 1 , adapter = \"com.squareup.wire.ProtoAdapter#STRING\" , label = WireField . Label . OMIT_IDENTITY ) val name : String = \"\" , picture_urls : List < String > = emptyList (), @field : WireField ( tag = 5 , adapter = \"com.squareup.geology.Period#ADAPTER\" , label = WireField . Label . OMIT_IDENTITY ) val period : Period = Period . CRETACEOUS , unknownFields : ByteString = ByteString . EMPTY ) : Message < Dinosaur , Nothing > ( ADAPTER , unknownFields ) { /** * URLs with images of this dinosaur. */ @field : WireField ( tag = 2 , adapter = \"com.squareup.wire.ProtoAdapter#STRING\" , label = WireField . Label . REPEATED , jsonName = \"pictureUrls\" ) val picture_urls : List < String > = immutableCopyOf ( \"picture_urls\" , picture_urls ) @Deprecated ( message = \"Shouldn't be used in Kotlin\" , level = DeprecationLevel . HIDDEN ) override fun newBuilder (): Nothing = throw AssertionError () override fun equals ( other : Any? ): Boolean { if ( other === this ) return true if ( other !is Dinosaur ) return false if ( unknownFields != other . unknownFields ) return false if ( name != other . name ) return false if ( picture_urls != other . picture_urls ) return false if ( period != other . period ) return false return true } override fun hashCode (): Int { var result = super . hashCode if ( result == 0 ) { result = unknownFields . hashCode () result = result * 37 + name . hashCode () result = result * 37 + picture_urls . hashCode () result = result * 37 + period . hashCode () super . hashCode = result } return result } override fun toString (): String { val result = mutableListOf < String > () result += \"\"\"name= ${ sanitize ( name ) } \"\"\" if ( picture_urls . isNotEmpty ()) result += \"\"\"picture_urls= ${ sanitize ( picture_urls ) } \"\"\" result += \"\"\"period= $ period \"\"\" return result . joinToString ( prefix = \"Dinosaur{\" , separator = \", \" , postfix = \"}\" ) } fun copy ( name : String = this . name , picture_urls : List < String > = this . picture_urls , period : Period = this . period , unknownFields : ByteString = this . unknownFields ): Dinosaur = Dinosaur ( name , picture_urls , period , unknownFields ) companion object { @JvmField val ADAPTER : ProtoAdapter < Dinosaur > = object : ProtoAdapter < Dinosaur > ( FieldEncoding . LENGTH_DELIMITED , Dinosaur :: class , \"type.googleapis.com/squareup.dinosaurs.Dinosaur\" , PROTO_3 , null ) { override fun encodedSize ( value : Dinosaur ): Int { var size = value . unknownFields . size if ( value . name != \"\" ) size += ProtoAdapter . STRING . encodedSizeWithTag ( 1 , value . name ) size += ProtoAdapter . STRING . asRepeated (). encodedSizeWithTag ( 2 , value . picture_urls ) if ( value . period != Period . CRETACEOUS ) size += Period . ADAPTER . encodedSizeWithTag ( 5 , value . period ) return size } override fun encode ( writer : ProtoWriter , value : Dinosaur ) { if ( value . name != \"\" ) ProtoAdapter . STRING . encodeWithTag ( writer , 1 , value . name ) ProtoAdapter . STRING . asRepeated (). encodeWithTag ( writer , 2 , value . picture_urls ) if ( value . period != Period . CRETACEOUS ) Period . ADAPTER . encodeWithTag ( writer , 5 , value . period ) writer . writeBytes ( value . unknownFields ) } override fun decode ( reader : ProtoReader ): Dinosaur { var name : String = \"\" val picture_urls = mutableListOf < String > () var period : Period = Period . CRETACEOUS val unknownFields = reader . forEachTag { tag -> when ( tag ) { 1 -> name = ProtoAdapter . STRING . decode ( reader ) 2 -> picture_urls . add ( ProtoAdapter . STRING . decode ( reader )) 5 -> try { period = Period . ADAPTER . decode ( reader ) } catch ( e : ProtoAdapter . EnumConstantNotFoundException ) { reader . addUnknownField ( tag , FieldEncoding . VARINT , e . value . toLong ()) } else -> reader . readUnknownField ( tag ) } } return Dinosaur ( name = name , picture_urls = picture_urls , period = period , unknownFields = unknownFields ) } override fun redact ( value : Dinosaur ): Dinosaur = value . copy ( unknownFields = ByteString . EMPTY ) } private const val serialVersionUID : Long = 0L } } Creating and accessing proto models is easy: val stegosaurus = Dinosaur ( name = \"Stegosaurus\" , period = Period . JURASSIC ) println ( \"My favorite dinosaur existed in the ${ stegosaurus . period } period.\" ) Here\u2019s how you can modify the object to add extra fields: val stegosaurus = stegosaurus . copy ( picture_urls = listOf ( \"https://www.flickr.com/photos/tags/Stegosaurus/\" ) ) println ( \"Here are some photos of ${ stegosaurus . name } : ${ stegosaurus . picture_urls } \" ) Wire gRPC \u00b6 Since version 3.0.0, Wire supports gRPC . Generating Code With Wire \u00b6 Wire can read .proto files from the local file system and from within .jar files. The compiler can optionally prune your schema to a subset of root types and their transitive dependencies. This is useful when sharing a schema between projects: a Java service and Android app may each use a subset of a larger shared schema. For more info on how to get started, see Wire Compiler & Gradle Plugin . If you don\u2019t use Gradle, the compiler also has a command line interface. Just substitute wire-compiler-VERSION-jar-with-dependencies.jar with the path to your jar. Download the latest precompiled jar. % java -jar wire-compiler-VERSION-jar-with-dependencies.jar \\ --proto_path=src/main/proto \\ --java_out=out \\ squareup/dinosaurs/dinosaur.proto \\ squareup/geology/period.proto Writing com.squareup.dinosaurs.Dinosaur to out Writing com.squareup.geology.Period to out Supplying the --android flag to the compiler causes Wire messages to implement Parcelable . If you use Proguard, then you need to add keep rules. The simplest option is to tell Proguard not to touch the Wire runtime library and your generated protocol buffers (of course these simple rules will miss opportunities to shrink and optimize the code): -keep class com.squareup.wire.** { *; } -keep class com.yourcompany.yourgeneratedcode.** { *; } Get Wire \u00b6 The wire-runtime package contains runtime support libraries that must be included in applications that use Wire-generated code. With Maven: <dependency> <groupId> com.squareup.wire </groupId> <artifactId> wire-runtime </artifactId> <version> 4.0.0-alpha.18 </version> </dependency> With Gradle: api \"com.squareup.wire:wire-runtime:4.0.0-alpha.18\" Snapshots of the development version are available in Sonatype\u2019s snapshots repository . Unsupported \u00b6 Wire does not support: Groups - they are skipped when parsing binary input data Wire supports custom options on messages and fields. Other custom options are ignored. Pass --excludes=google.protobuf.* to the compiler to omit options from the generated code. Further Documentation \u00b6 See Google\u2019s excellent documentation on the structure and syntax of proto schemas.","title":"Overview"},{"location":"#wire","text":"\u201cA man got to have a code!\u201d - Omar Little As our teams and programs grow, the variety and volume of data also grows. Success will turn your simple data models into complex ones! Whether your application is storing data to disk or transmitting it over a network, the structure and interpretation of that data should be clear. Consumers work best with data they understand! Schemas describe and document data models. If you have data, you should have a schema.","title":"Wire"},{"location":"#protocol-buffers","text":"Google\u2019s Protocol Buffers are built around a great schema language: It\u2019s cross platform and language independent. Whatever programming language you use, you\u2019ll be able to use proto schemas with your application. Proto schemas are backwards-compatible and future-proof. You can evolve your schema as your application loses old features and gains new ones. It\u2019s focused. Proto schemas describe your data models. That\u2019s it. Here\u2019s a sample message definition: syntax = \"proto3\" ; package squareup . dinosaurs ; option java_package = \"com.squareup.dinosaurs\" ; import \"squareup/geology/period.proto\" ; message Dinosaur { // Common name of this dinosaur, like \"Stegosaurus\". string name = 1 ; // URLs with images of this dinosaur. repeated string picture_urls = 2 ; squareup.geology.Period period = 5 ; } And here\u2019s an enum definition: syntax = \"proto3\" ; package squareup . geology ; option java_package = \"com.squareup.geology\" ; enum Period { // 145.5 million years ago \u2014 66.0 million years ago. CRETACEOUS = 0 ; // 201.3 million years ago \u2014 145.0 million years ago. JURASSIC = 1 ; // 252.17 million years ago \u2014 201.3 million years ago. TRIASSIC = 2 ; } This schema language is Protocol Buffers\u2019 best feature. You might even use it purely for documentation purposes, such as to describe a JSON API. Protocol Buffers also defines a compact binary encoding of messages that conform to the schema. This encoding is fast to encode, fast to decode, small to transmit, and small to store. The binary encoding uses numeric tags from the schema, like the 5 for period above. For example, let\u2019s encode this dinosaur: { name: \"Stegosaurus\", period: JURASSIC } The encoded value is just 15 bytes: Hex Description 0a tag: name(1), field encoding: LENGTH_DELIMITED(2). 1 << 3 | 2 0b \"Stegosaurus\".length() 53 'S' 74 't' 65 'e' 67 'g' 6f 'o' 73 's' 61 'a' 75 'u' 72 'r' 75 'u' 73 's' 28 tag: period(5), field encoding: VARINT(0). 5 << 3 | 0 02 JURASSIC(2)","title":"Protocol Buffers"},{"location":"#why-wire","text":"The Protocol Buffers schema language and binary encoding are both defined by Google. Wire is an independent implementation from Square that\u2019s specifically designed for Android and Java. For each message type defined in the schema, Wire generates an immutable model class and its builder. The generated code looks like code you\u2019d write by hand: it\u2019s documented, formatted, and simple. Wire\u2019s APIs should feel at home to programmers who like Effective Java . That said, there are some interesting design decisions in Wire: Wire messages declare public final fields instead of the usual getter methods. This cuts down on both code generated and code executed. Less code is particularly beneficial for Android programs. Wire avoids case mapping. A field declared as picture_urls in a schema yields a Java field picture_urls and not the conventional pictureUrls camel case. Though the name feels awkward at first, it\u2019s fantastic whenever you use grep or more sophisticated search tools. No more mapping when navigating between schema, Java source code, and data. It also provides a gentle reminder to calling code that proto messages are a bit special. Primitive types are always boxed. If a field is absent, its value is null . This is used for naturally optional fields, such as a dinosaur whose period is unknown. A field may also be null due to schema evolution: if tomorrow we add a carnivore boolean to our message definition, today\u2019s data won\u2019t have a value for that field. Here\u2019s the compact generated code for the Dinosaur message defined above: // Code generated by Wire protocol buffer compiler, do not edit. // Source: squareup.dinosaurs.Dinosaur in squareup/dinosaurs/dinosaur.proto package com.squareup.dinosaurs ; import com.squareup.geology.Period ; import com.squareup.wire.Message ; import com.squareup.wire.ProtoAdapter ; import com.squareup.wire.Syntax ; import com.squareup.wire.WireField ; import com.squareup.wire.internal.Internal ; import java.lang.Object ; import java.lang.Override ; import java.lang.String ; import java.util.List ; import okio.ByteString ; public final class Dinosaur extends Message < Dinosaur , Dinosaur . Builder > { public static final ProtoAdapter < Dinosaur > ADAPTER = ProtoAdapter . newMessageAdapter ( Dinosaur . class , \"type.googleapis.com/squareup.dinosaurs.Dinosaur\" , Syntax . PROTO_3 ); private static final long serialVersionUID = 0 L ; /** * Common name of this dinosaur, like \"Stegosaurus\". */ @WireField ( tag = 1 , adapter = \"com.squareup.wire.ProtoAdapter#STRING\" , label = WireField . Label . OMIT_IDENTITY ) public final String name ; /** * URLs with images of this dinosaur. */ @WireField ( tag = 2 , adapter = \"com.squareup.wire.ProtoAdapter#STRING\" , label = WireField . Label . REPEATED , jsonName = \"pictureUrls\" ) public final List < String > picture_urls ; @WireField ( tag = 5 , adapter = \"com.squareup.geology.Period#ADAPTER\" , label = WireField . Label . OMIT_IDENTITY ) public final Period period ; public Dinosaur ( String name , List < String > picture_urls , Period period ) { this ( name , picture_urls , period , ByteString . EMPTY ); } public Dinosaur ( String name , List < String > picture_urls , Period period , ByteString unknownFields ) { super ( ADAPTER , unknownFields ); if ( name == null ) { throw new IllegalArgumentException ( \"name == null\" ); } this . name = name ; this . picture_urls = Internal . immutableCopyOf ( \"picture_urls\" , picture_urls ); if ( period == null ) { throw new IllegalArgumentException ( \"period == null\" ); } this . period = period ; } @Override public Builder newBuilder () { Builder builder = new Builder (); builder . name = name ; builder . picture_urls = Internal . copyOf ( picture_urls ); builder . period = period ; builder . addUnknownFields ( unknownFields ()); return builder ; } @Override public boolean equals ( Object other ) { if ( other == this ) return true ; if ( ! ( other instanceof Dinosaur )) return false ; Dinosaur o = ( Dinosaur ) other ; return unknownFields (). equals ( o . unknownFields ()) && Internal . equals ( name , o . name ) && picture_urls . equals ( o . picture_urls ) && Internal . equals ( period , o . period ); } @Override public int hashCode () { int result = super . hashCode ; if ( result == 0 ) { result = unknownFields (). hashCode (); result = result * 37 + ( name != null ? name . hashCode () : 0 ); result = result * 37 + picture_urls . hashCode (); result = result * 37 + ( period != null ? period . hashCode () : 0 ); super . hashCode = result ; } return result ; } public static final class Builder extends Message . Builder < Dinosaur , Builder > { public String name ; public List < String > picture_urls ; public Period period ; public Builder () { name = \"\" ; picture_urls = Internal . newMutableList (); period = Period . CRETACEOUS ; } /** * Common name of this dinosaur, like \"Stegosaurus\". */ public Builder name ( String name ) { this . name = name ; return this ; } /** * URLs with images of this dinosaur. */ public Builder picture_urls ( List < String > picture_urls ) { Internal . checkElementsNotNull ( picture_urls ); this . picture_urls = picture_urls ; return this ; } public Builder period ( Period period ) { this . period = period ; return this ; } @Override public Dinosaur build () { return new Dinosaur ( name , picture_urls , period , super . buildUnknownFields ()); } } } The Java code to create and access proto models is compact and readable: Dinosaur stegosaurus = new Dinosaur . Builder () . name ( \"Stegosaurus\" ) . period ( Period . JURASSIC ) . build (); System . out . println ( \"My favorite dinosaur existed in the \" + stegosaurus . period + \" period.\" ); Each type has a corresponding ProtoAdapter that can encode a message to bytes and decode bytes back into a message. Dinosaur stegosaurus = ... byte [] stegosaurusBytes = Dinosaur . ADAPTER . encode ( stegosaurus ); byte [] tyrannosaurusBytes = ... Dinosaur tyrannosaurus = Dinosaur . ADAPTER . decode ( tyrannosaurusBytes ); When accessing a field, use Wire.get() to replace null values with the corresponding default: Period period = Wire . get ( stegosaurus . period , Dinosaur . DEFAULT_PERIOD ); This is equivalent to the following: Period period = stegosaurus.period != null ? stegosaurus.period : Dinosaur.DEFAULT_PERIOD;","title":"Why Wire?"},{"location":"#wire-kotlin","text":"Since version 3.0.0, Wire can generate Kotlin code. See Wire Compiler & Gradle Plugin to learn how to configure your build. Kotlin is a pragmatic and expressive programming language that makes it easy to model data. Here\u2019s how we used Kotlin to model Protocol Buffers messages: Messages feel like data classes, but in fact they\u2019re not. Compiler still generates equals() , hashCode() , toString() and copy() for you. Wire does not generate componentN() functions though, we believe that destructuring declarations are not a good fit for Protocol Buffers: a change in the schema that removes or adds a field might lead to a situation when your destructuring declaration still compiles but now describes a completely different subset of fields, rendering your code incorrect. copy() is a substitute for the Builder , which is not used anymore. If your program relies on the Builder to be present, you may generate code in Java interoperability mode - Wire Compiler & Gradle Plugin explains how that works. Fields are generated as properties. While this is idiomatic in Kotlin, Java code will now have to access fields using getters. If your program relies on accessing fields directly, use Java interoperability mode - the compiler will generate @JvmField annotations for each field. The nullability of each field\u2019s type depends on its label: required , repeated and map fields get non-nullable types, whereas optional fields are of nullable types. With the exception of required fields, each field has a default value: null for optional fields, emptyList() for repeated fields, emptyMap() for map fields. Here\u2019s the same Dinosaur message in Kotlin: // Code generated by Wire protocol buffer compiler, do not edit. // Source: squareup.dinosaurs.Dinosaur in squareup/dinosaurs/dinosaur.proto package com.squareup.dinosaurs import com.squareup.geology.Period import com.squareup.wire.FieldEncoding import com.squareup.wire.Message import com.squareup.wire.ProtoAdapter import com.squareup.wire.ProtoReader import com.squareup.wire.ProtoWriter import com.squareup.wire.Syntax.PROTO_3 import com.squareup.wire.WireField import com.squareup.wire.internal.immutableCopyOf import com.squareup.wire.internal.sanitize import kotlin.Any import kotlin.AssertionError import kotlin.Boolean import kotlin.Deprecated import kotlin.DeprecationLevel import kotlin.Int import kotlin.Long import kotlin.Nothing import kotlin.String import kotlin.collections.List import kotlin.hashCode import kotlin.jvm.JvmField import okio.ByteString class Dinosaur ( /** * Common name of this dinosaur, like \"Stegosaurus\". */ @field : WireField ( tag = 1 , adapter = \"com.squareup.wire.ProtoAdapter#STRING\" , label = WireField . Label . OMIT_IDENTITY ) val name : String = \"\" , picture_urls : List < String > = emptyList (), @field : WireField ( tag = 5 , adapter = \"com.squareup.geology.Period#ADAPTER\" , label = WireField . Label . OMIT_IDENTITY ) val period : Period = Period . CRETACEOUS , unknownFields : ByteString = ByteString . EMPTY ) : Message < Dinosaur , Nothing > ( ADAPTER , unknownFields ) { /** * URLs with images of this dinosaur. */ @field : WireField ( tag = 2 , adapter = \"com.squareup.wire.ProtoAdapter#STRING\" , label = WireField . Label . REPEATED , jsonName = \"pictureUrls\" ) val picture_urls : List < String > = immutableCopyOf ( \"picture_urls\" , picture_urls ) @Deprecated ( message = \"Shouldn't be used in Kotlin\" , level = DeprecationLevel . HIDDEN ) override fun newBuilder (): Nothing = throw AssertionError () override fun equals ( other : Any? ): Boolean { if ( other === this ) return true if ( other !is Dinosaur ) return false if ( unknownFields != other . unknownFields ) return false if ( name != other . name ) return false if ( picture_urls != other . picture_urls ) return false if ( period != other . period ) return false return true } override fun hashCode (): Int { var result = super . hashCode if ( result == 0 ) { result = unknownFields . hashCode () result = result * 37 + name . hashCode () result = result * 37 + picture_urls . hashCode () result = result * 37 + period . hashCode () super . hashCode = result } return result } override fun toString (): String { val result = mutableListOf < String > () result += \"\"\"name= ${ sanitize ( name ) } \"\"\" if ( picture_urls . isNotEmpty ()) result += \"\"\"picture_urls= ${ sanitize ( picture_urls ) } \"\"\" result += \"\"\"period= $ period \"\"\" return result . joinToString ( prefix = \"Dinosaur{\" , separator = \", \" , postfix = \"}\" ) } fun copy ( name : String = this . name , picture_urls : List < String > = this . picture_urls , period : Period = this . period , unknownFields : ByteString = this . unknownFields ): Dinosaur = Dinosaur ( name , picture_urls , period , unknownFields ) companion object { @JvmField val ADAPTER : ProtoAdapter < Dinosaur > = object : ProtoAdapter < Dinosaur > ( FieldEncoding . LENGTH_DELIMITED , Dinosaur :: class , \"type.googleapis.com/squareup.dinosaurs.Dinosaur\" , PROTO_3 , null ) { override fun encodedSize ( value : Dinosaur ): Int { var size = value . unknownFields . size if ( value . name != \"\" ) size += ProtoAdapter . STRING . encodedSizeWithTag ( 1 , value . name ) size += ProtoAdapter . STRING . asRepeated (). encodedSizeWithTag ( 2 , value . picture_urls ) if ( value . period != Period . CRETACEOUS ) size += Period . ADAPTER . encodedSizeWithTag ( 5 , value . period ) return size } override fun encode ( writer : ProtoWriter , value : Dinosaur ) { if ( value . name != \"\" ) ProtoAdapter . STRING . encodeWithTag ( writer , 1 , value . name ) ProtoAdapter . STRING . asRepeated (). encodeWithTag ( writer , 2 , value . picture_urls ) if ( value . period != Period . CRETACEOUS ) Period . ADAPTER . encodeWithTag ( writer , 5 , value . period ) writer . writeBytes ( value . unknownFields ) } override fun decode ( reader : ProtoReader ): Dinosaur { var name : String = \"\" val picture_urls = mutableListOf < String > () var period : Period = Period . CRETACEOUS val unknownFields = reader . forEachTag { tag -> when ( tag ) { 1 -> name = ProtoAdapter . STRING . decode ( reader ) 2 -> picture_urls . add ( ProtoAdapter . STRING . decode ( reader )) 5 -> try { period = Period . ADAPTER . decode ( reader ) } catch ( e : ProtoAdapter . EnumConstantNotFoundException ) { reader . addUnknownField ( tag , FieldEncoding . VARINT , e . value . toLong ()) } else -> reader . readUnknownField ( tag ) } } return Dinosaur ( name = name , picture_urls = picture_urls , period = period , unknownFields = unknownFields ) } override fun redact ( value : Dinosaur ): Dinosaur = value . copy ( unknownFields = ByteString . EMPTY ) } private const val serialVersionUID : Long = 0L } } Creating and accessing proto models is easy: val stegosaurus = Dinosaur ( name = \"Stegosaurus\" , period = Period . JURASSIC ) println ( \"My favorite dinosaur existed in the ${ stegosaurus . period } period.\" ) Here\u2019s how you can modify the object to add extra fields: val stegosaurus = stegosaurus . copy ( picture_urls = listOf ( \"https://www.flickr.com/photos/tags/Stegosaurus/\" ) ) println ( \"Here are some photos of ${ stegosaurus . name } : ${ stegosaurus . picture_urls } \" )","title":"Wire Kotlin"},{"location":"#wire-grpc","text":"Since version 3.0.0, Wire supports gRPC .","title":"Wire gRPC"},{"location":"#generating-code-with-wire","text":"Wire can read .proto files from the local file system and from within .jar files. The compiler can optionally prune your schema to a subset of root types and their transitive dependencies. This is useful when sharing a schema between projects: a Java service and Android app may each use a subset of a larger shared schema. For more info on how to get started, see Wire Compiler & Gradle Plugin . If you don\u2019t use Gradle, the compiler also has a command line interface. Just substitute wire-compiler-VERSION-jar-with-dependencies.jar with the path to your jar. Download the latest precompiled jar. % java -jar wire-compiler-VERSION-jar-with-dependencies.jar \\ --proto_path=src/main/proto \\ --java_out=out \\ squareup/dinosaurs/dinosaur.proto \\ squareup/geology/period.proto Writing com.squareup.dinosaurs.Dinosaur to out Writing com.squareup.geology.Period to out Supplying the --android flag to the compiler causes Wire messages to implement Parcelable . If you use Proguard, then you need to add keep rules. The simplest option is to tell Proguard not to touch the Wire runtime library and your generated protocol buffers (of course these simple rules will miss opportunities to shrink and optimize the code): -keep class com.squareup.wire.** { *; } -keep class com.yourcompany.yourgeneratedcode.** { *; }","title":"Generating Code With Wire"},{"location":"#get-wire","text":"The wire-runtime package contains runtime support libraries that must be included in applications that use Wire-generated code. With Maven: <dependency> <groupId> com.squareup.wire </groupId> <artifactId> wire-runtime </artifactId> <version> 4.0.0-alpha.18 </version> </dependency> With Gradle: api \"com.squareup.wire:wire-runtime:4.0.0-alpha.18\" Snapshots of the development version are available in Sonatype\u2019s snapshots repository .","title":"Get Wire"},{"location":"#unsupported","text":"Wire does not support: Groups - they are skipped when parsing binary input data Wire supports custom options on messages and fields. Other custom options are ignored. Pass --excludes=google.protobuf.* to the compiler to omit options from the generated code.","title":"Unsupported"},{"location":"#further-documentation","text":"See Google\u2019s excellent documentation on the structure and syntax of proto schemas.","title":"Further Documentation"},{"location":"changelog/","text":"Change Log \u00b6 Version 4.0.0-alpha.18 \u00b6 2021-11-22 Fix: In Java, rename instances to avoid field and class name conflicts. New: Wire should build and execute properly on Windows. Version 4.0.0-alpha.17 \u00b6 2021-11-11 Fix: Validate enum constant uniqueness for the entire package. Fix: Compile Kotlin/JS with both LEGACY and IR compilers. Fix: Don\u2019t depend on moshi-kotlin in wire-moshi. This caused a transitive dependency on kotlin-reflect, which we neither needed nor wanted. Version 4.0.0-alpha.16 \u00b6 2021-11-09 Fix: Don\u2019t generate invalid code when an enum constant is named name or ordinal . Fix: Deep copy metadata on GrpcCall.clone() . Fix: Support reporting errors in CustomHandlerBeta . Upgrade: Okio 3.0.0 . This is binary-incompatible with the Okio 3.0 alpha releases. Version 3.7.1 \u00b6 2021-11-03 Fix: Properly load schema located at root without packages. Version 4.0.0-alpha.15 \u00b6 2021-10-21 Fix: Support for serializing builder-less Kotlin generated classes to JSON. Fix: Wire Gradle plugin tasks have been modernized with configuration caching support. Version 4.0.0-alpha.13 \u00b6 2021-10-12 Fix: Memory fixes found with Address Sanitizer in Swift. Version 4.0.0-alpha.11 \u00b6 2021-09-02 New: change the Gradle plugin so that (unstable) custom handlers can be configured with instance instead of with a class name. Note that releases 4.0.0-alpha.9 and 4.0.0-alpha.10 were published incorrectly and should not be used. Version 4.0.0-alpha.8 \u00b6 2021-08-30 This release drops the -multiplatform suffix on Kotlin Multiplatform artifacts. All artifacts now share the same name (like com.squareup.wire:wire-runtime:4.0.0-alpha.8 ) for both Kotlin/JVM and Kotlin Multiplatform. New: Programmatic API to prune schemas. See Pruner in wire-schema. New: Expose the source .proto file at ProtoAdaper.sourceFile . This is null for built-in types and types generated prior to this release. Fix: Retain field order when emitting a schema as .proto files. Fix: Support Kotlin-generated annotations on Java fields. Fix: Locate files in the root package when importing. Version 4.0.0-alpha.7 \u00b6 2021-08-09 Fix: Use correct type when referencing a custom adapter in Kotlin generated code. Fix: Handle writing/reading exceptions for duplex calls in Wire gRPC. Version 4.0.0-alpha.6 \u00b6 2021-08-03 Fix: Explicitly defined Wire gRPC server generation as experimental: the feature isn\u2019t complete. Fix: Suppress deprecation warnings on generated enum\u2019s fromValue method in Kotlin. Fix: Use relative path sensitivity and file collection. Version 4.0.0-alpha.5 \u00b6 2021-06-24 Kotlin + Java New: Generate Kotlin code whose members match the declaration order of the corresponding .proto files. In previous releases, generated members were sorted by kind (fields, oneofs), then by declaration order. With this update only declaration order is used. Note that this will change the encoded-bytes of these messages. This change is both forwards and backwards-compatible. Identical encoding of equal messages across Wire releases is typical but not guaranteed, and this is a rare release that changes that encoding. If you do cryptographic hashes on encoded proto messages, you will notice that the hashes are different in this release. Fix: Redact boxed OneOf fields. Fix: Don\u2019t crash encoding schemas when an option contains a repeated field, an enum, or a double. Fix: Be more aggressive about loading transitive files with SchemaLoader.loadExhaustively . Fix: Don\u2019t break task caching by using absolute paths in the Gradle plugin. Wire now uses project-relative paths in any attribute that is used as a cache key. Version 4.0.0-alpha.4 \u00b6 2021-06-15 Kotlin + Java New: Define oneofName in @WireField . New: Option in SchemaLoader to exhaustively load imported files. By default we only load what\u2019s immediately necessary to generate code; this new option loads everything reachable into the schema. Version 4.0.0-alpha.3 \u00b6 2021-06-03 Kotlin + Java New: Support for special float literals. New: Support for Android variants. New: Add \u2018nameSuffix\u2019 parameter for configuring generated service-class names in Kotlin. New: Support for glob syntax in srcJar includes. Fix: Redacted Kotlin scalars now respect nullability. Update: Update KotlinPoet to 1.8.0 . Bye: Drop support for emitKotlinxSerialization. Version 4.0.0-alpha.2 \u00b6 2021-05-11 Kotlin + Java New: @WireRpc has a new sourceFile attribute. New: wire-reflector bundles gRPC\u2019s reflection.proto which it is built upon. Version 4.0.0-alpha.1 \u00b6 2021-05-01 Kotlin + Java New: GrpcClient.Builder.minMessageToCompress() configures which messages are compressed. This will completely disable compression if the size is Long.MAX_VALUE . We\u2019ve seen problems where some Golang gRPC servers don\u2019t support compression; setting this to MAX_VALUE is necessary to interop with them. New: SchemaReflector is our initial implementation of the gRPC Server Reflection Protocol . Note that although we implement the business logic of gRPC reflection, we don\u2019t offer a gRPC server built into Wire. New: Support rpcRole = 'none' in the Gradle plugin to generate neither client nor server code. Fix: Generate @Deprecated annotations on deprecated messages, fields, enums, and enum constants. Fix: Update the Wire Gradle plugin to register generated .java sources with the Java compiler. Previously this was broken if the Kotlin plugin was installed. Fix: Use Gradle\u2019s logging mechanism to reduce output when Wire generates code. Fix: Update the Wire Gradle plugin to clear the output directory before generating code. This prevents the need to do a clean build after removing a message type. Fix: Permit values other than 0 and 1 when decoding protobuf-encoded booleans. Previously we threw an IOException for other values; now all non-zero values are true. Upgrade: Okio 3.0.0-alpha.3 . We now use Okio 3\u2019s FileSystem in SchemaLoader , which makes it easier to load .proto files from the classpath. Swift : New: Support Timestamp and Duration . Fix: Throw an error when encountering an unexpected ProtoReader.beginMessage() rather than calling fatalError() . Version 3.7.0 \u00b6 2021-03-25 New: srcProject(\":project-name\") makes it easier to depend on .proto files of other projects. Fix: Don\u2019t require source that .proto directories exist at Gradle plugin configuration time. This was preventing Wire from using other tasks\u2019 outputs as its inputs. Fix: Don\u2019t fail if options have a . prefix. Version 3.6.1 \u00b6 2021-03-09 Fix: The Wire Gradle plugin now supports Java only Android projects. Fix: In the Wire Gradle plugin, sourcePath will now include only protos defined with include if the option is present. It used to include all existing .proto files even if include was used. New: Full support Optional Int64 and UInt64 for JSONString in Swift. Version 3.6.0 \u00b6 2021-02-08 New: Automatically add a dependency when a protoPath or protoSource depends on a project. New: protoPath and protoSource dependencies are now not transitive by default. New: New protoLibrary option for the Wire Gradle plugin. Configuring a project as a protoLibrary will cause the generated .jar file to include .proto sources. New: Code generation for plain gRPC server. The Kotlin target now has a new grpcServerCompatible option which if set to true will generate gRPC server-compatible classes. New: Introduce GrpcException . New: Add GrpcMethod tag to the request. New: Adds redacting support for Moshi JSON adapters. New: Publish plugin marker for Gradle plugin. Fix: Escape square brackets in Kotlin generated code documentation. Fix: Improved proto parsing performance. Version 3.5.0 \u00b6 2020-10-27 New: Wire Gradle plugin improvements: A task is now created for each available sources (main, Android variants, etc). The wire-runtime dependency is automatically added. Generated code directories are automatically added into their module\u2019s source sets. New: Wire\u2019s proto parser now knows about oneOfOptions . New: Wire will throw when two enum constants are ambiguous, like ZERO and zero . New: Bytes options are not eligible anymore as annotation members. Fix: Optional fields in proto3 are now generated as nullable fields. Fix: JSON camel-casing is updated to fit latest protobuf specifications. Fix: Exception messages when gRPC fails have been improved. Fix: Allow ; as entry separator in option maps. Fix: Enum constants are now properly escaped when conflicting with keywords of their generated target platform. Fix: Update to KotlinPoet 1.7.2 which makes a lot of change in how Kotlin code is generated. Version 3.4.0 \u00b6 2020-09-24 New: Stop emitting enum constant options as fields for Kotlin. New: The Wire Gradle plugin task is now cacheable. New: New GrpcCall function to help implement fakes. New: Change GrpcStreamingCall.execute() to support structured concurrency. Version 3.3.0 \u00b6 2020-09-14 New: Proto3 support! This includes the new behaviors, the new types, and the JSON. New: Swift support for proto2 schemas. The details are in our blog post . New: Wire will now throw an error when: two generated files end up overriding each other, imports form a cycle, packages form a cycle. This can be turned off with the flag permitPackageCycles , an option within the source set cannot be resolved, there are name duplications of members in a message, or of rpcs in a service, a map is used as an extension. New: Support for the json_name pseudo option. New: The wire_package file option allows one to set the JVM package where classes generated from the concerned file will be placed. wire_package takes precedence over java_package . New: Lists and maps in Kotlin generated code are now immutable. New: Support UTF-8 with BOM in proto files. New: wire.since and wire.until have been renamed with the prefix constant_ for EnumValueOptions . New: Wire generates 1) annotations for options which 2) gets assigned to the generated code where appropriate. Both behavior can be turn on or off via the flags: emitDeclaredOptions : True to emit types for options declared on messages, fields, etc. Default to true, emitAppliedOptions : True to emit annotations for options applied on messages, fields, etc. Default to false. Fix: Recursive map values. Fix: Long expressions in equals and encodedSize functions. Version 3.2.2 \u00b6 2020-05-15 Fix: JSON serialization correctly emits all values. Version 3.2.1 \u00b6 2020-05-02 New: onlyVersion option on the Wire Gradle plugin to target a unique version. By and large, service code that supports many clients would target ranges via sinceVersion and untilVersion , while client code would target a unique version via onlyVersion . New: Support for optional fields in Proto3. Fix: Restored the GrpcClient.create API to create implementations for gRPC interfaces. Version 3.2.0 \u00b6 2020-04-23 New: wire.since and wire.until options on members and enum values. You can prune fields or constants using these two options. When generating code with the Wire Gradle plugin, define sinceVersion and/or untilVersion to scope the generated code. New: Messages\u2019 toString method on Kotlin and Java now escape string values for easy parsing. Fix: Link the entire descriptor.proto every time when building the Schema . Fix: Properly handle members named after keywords of the target language for both Java and Kotlin. Fix: Use the declared name for keys in JSON when emitting/reading keyword named members. Fix: Generated Kotlin code is malformed for long identifiers. Fix: Make the Wire Gradle plugin compatible with instant execution. Version 3.1.0 \u00b6 2020-02-06 This release includes major non-backwards-compatible API changes to the wire-schema module. This will break tools that use Wire\u2019s schema modeling as a standalone library. We are making big changes to this component and we sacrificed API compatibility to accelerate these improvements. New: proto { ... } target in the Wire Gradle plugin. Use this to perform basic source code transformations on collections of .proto files. We use it to prune large collections of protos to just the subset used by the application. Fix: Support all forms of reserved extensions, such as extensions 1, 3 to 5, 7; . Fix: Don\u2019t re-generate source files when their .proto files haven\u2019t changed. New: includes , excludes , root , and prune give precedence to the most precise rule. Previously excludes always took precedence over includes , and prune always took precedence over root . Fix: Generate non-instantiable class for enclosing types in Kotlin. These are emitted when a nested type is retained but its enclosing type is pruned. Fix: Do not fail to build when the profile cannot find a dependency. Version 3.0.3 \u00b6 2019-12-23 Starting with this version the Wire Maven plugin is no longer maintained and has been removed from the repository. New: Support for custom options in Kotlin. New: Kotlin 1.3.61. New: Add support for custom targets in WireRun and the Gradle plugin. New: Improve schema evaluation algorithm when loading separate sourcePath and protoPath . New: Lazy loading of protoPath contents. New: Make it possible to customize Gradle plugin\u2019s configurations. New: Make it possible to customize Gradle plugin\u2019s generateProtos task. Fix: Use correct ProtoAdapter for packed fields in Kotlin. Fix: Properly handle name clashes between fields and enclosing types. Fix: Preserve the package name on files loaded from protoPath . Fix: ProtoPruner: Properly evaluate Pruner\u2019s reachable objects. Fix: ProtoPruner: Ensure --excludes properly prunes options. Fix: ProtoPruner: Keep used ServiceOptions and MethodOptions when pruning. Version 3.0.2 \u00b6 2019-11-22 Fix: Generate correct unknownFields code if a message field\u2019s name is a Kotlin keyword. Fix: Properly handle unknown enum values in Kotlin. Fix: ProtoPruner: retain used extends. Fix: ProtoPruner: retain only used imports. Fix: ProtoPruner: use NewSchemaLoader that correctly loads google.protobuf.descriptor. Fix: ProtoPruner: print default values for scalar types for proto target within the options. Fix: ProtoPruner: fix handling of options. Fix: ProtoPruner: print default values for enums. Version 3.0.1 \u00b6 2019-10-18 Fix: Use the correct adapter path for gRPC endpoints that customize the Java package. Fix: Preserve documentation in generated services. Fix: Fail to generate code if the source directory doesn\u2019t exist. Fix: Make Kotlin consistent with Java for unknown enum constants. We now treat these as unknown fields rather than failing to decode the enclosing message. Version 3.0.0 \u00b6 2019-10-07 Update: All gRPC networking calls are encoded in gzip. Version 3.0.0-rc03 \u00b6 2019-10-04 Fix: Update dependency to a stable version, 2.4.1 of Okio. Version 3.0.0-rc02 \u00b6 2019-10-01 Kotlin \u00b6 Fix: Nullify other oneof fields in Builder setters in Kotlin interop. Fix: Use unknownFields in hashCode() . Fix: Remove withoutUnknownFields() from Kotlin. gRPC \u00b6 Update: Total rewrite of the generated interfaces for clients: Introduce two interfaces, GrpcCall for simple RPCs, and GrpcStreamingCall fox duplex ones. Both will provide blocking and suspending API, including a reference to the underlying OkHttp Call object and its timeout. Fix: Send stream cancels from clients. Misc \u00b6 New: Changes printing of options and enums: No empty lines between options and fields for enums. Print options on new lines only when more than one. Fix: Don\u2019t cache Message\u2019s hash code on Native. Fix: Fix handling of map values in FieldBinding . Fix: Fix import fails on windows due to path separator. Fix: Don\u2019t emit proto2 sources for proto3 syntax. Version 3.0.0-rc01 \u00b6 2019-08-02 Compiler + Gradle plugin \u00b6 New: Support includes on Maven coordinate dependencies. New: Track includes separately for source vs proto paths. New: Follow symlinks when building. New: Change the Gradle plugin to track targets as a list. New: Includes and Excludes for Wire targets. New: Print errors on ambiguous and missing imports. Fix: Fix a bug where protopath Maven resources weren\u2019t working. Fix: Don\u2019t reuse source dependencies as protopath dependencies. Fix: Fix equals() implementation for messages with no fields. Kotlin \u00b6 New: Move Wire.kt into jvmMain to discourage its use in common Kotlin code. New: Make Message.adapter a val . New: Optimize decode() code for protos with no fields. New: Update supported Native platforms. New: Make Message.unknownFields property non-nullable. New: Make Message.unknownFields a val . Fix: Don\u2019t use KClass.simpleName to avoid needing kotlin-reflect dependency. Fix: Use kotlin.UnsupportedOperationException in generated code. gRPC \u00b6 New: Introduce MessageSource and MessageSink interfaces in wire-runtime . New: Honor Java package names in Wire gRPC services. New: Make PipeDuplexRequestBody internal. Fix: Workaround for @Generated annotation on Java 9+. Fix: Fix types for blocking APIs. Misc \u00b6 Fix: Fix deserializing null values in Gson adapter. Fix: Change wire-runtime artifact names to preserve 2.x compatibility. Version 3.0.0-alpha03 \u00b6 2019-06-22 Similar to alpha02, but with proper wire-runtime multiplatform artifacts. Version 3.0.0-alpha02 \u00b6 2019-06-21 New: Experimental multiplatform runtime. Starting with this version, wire-runtime is published as a multiplatform Kotlin artifact. While the JVM artifact is binary- and behavior-compatible with 3.0.0-alpha01, artifacts for other platforms may not work correctly at this point. The artifact name for the JVM artifact has been changed to wire-runtime-jvm : now, in order to depend on the multiplatform runtime, use the following Gradle dependency declaration: api \"com.squareup.wire:wire-runtime:3.0.0-alpha02\" and if you want to depend on the JVM artifact only, use the following declaration: api \"com.squareup.wire:wire-runtime-jvm:3.0.0-alpha02\" New: Generate RPCs as Single Abstract Methods. New: Add \u201csingleMethod\u201d Gradle plugin configuration for services. New: Add \u201cblockingServices\u201d Gradle plugin configuration for services. New: Support packageless services code generation. New: Remove sealed classes-based oneof implementation. New: Don\u2019t generate a Builder for non-interop Kotlin messages. Fix: Kotlin Generator correctly generates code for Protobuf services. Fix: Improved formatting of generated Kotlin code. Fix: Generate correct adapter names for WireField annotation. Fix: Generate labels for WireField annotation. Fix: Wrap oneof error message properly. Version 3.0.0-alpha01 \u00b6 2019-03-14 New: Kotlin Generator Wire 3 can generate Kotlin data classes. To enable this feature via the command line API, pass in the --kotlin_out parameter that should specify the output directory for the generated *.kt files. Given the following simple proto: message Person { required string name = 1 ; required int32 id = 2 ; optional string email = 3 ; } the generated Kotlin code will look like the following: data class Person ( @field : WireField ( tag = 1 , adapter = \"com.squareup.wire.ProtoAdapter#STRING\" ) val name : String , @field : WireField ( tag = 2 , adapter = \"com.squareup.wire.ProtoAdapter#INT32\" ) val id : Int , @field : WireField ( tag = 3 , adapter = \"com.squareup.wire.ProtoAdapter#STRING\" ) val email : String? = null , val unknownFields : ByteString = ByteString . EMPTY ) : Message < Person , Person . Builder > ( ADAPTER , unknownFields ) { companion object { @JvmField val ADAPTER : ProtoAdapter < Person > = ... // code omitted for brevity The copy() method of a data class replaces most usages of the builder. If your code relies on the Builder , you can enable full Builder generation by passing the --java_interop parameter to the compiler. New: gRPC support In addition to generating Kotlin code from proto messages, Wire can now generate code for gRPC endpoints. Here\u2019s an example schema: service RouteGuide { // A simple RPC. // // Obtains the feature at a given position. // // A feature with an empty name is returned if there's no feature at the given // position. rpc GetFeature ( Point ) returns ( Feature ) {} } The generated code will look like the following (message protos, referenced by the schema, are omitted): interface RouteGuide : Service { @WireRpc ( path = \"/routeguide.RouteGuide/GetFeature\" , requestAdapter = \"routeguide.Point#ADAPTER\" , responseAdapter = \"routeguide.Feature#ADAPTER\" ) suspend fun GetFeature ( request : Point ): Feature } All four gRPC modes are supported: the generated code uses suspendable functions to implement non-blocking asynchronous execution. In streaming modes, ReceiveChannel and SendChannel are used to listen to asynchronous data in a non-blocking fashion. This feature works out of the box in Wire 3 compiler as long as the input file contains a gRPC schema. New: Gradle plugin Here\u2019s an example Gradle configuration: apply plugin: 'com.squareup.wire' wire { // Keeps only 'Dinosaur#name' as the root of the object graph roots 'squareup.dinosaurs.Dinosaur#name' // Keeps all fields, except 'name', in 'Dinosaur' prunes 'squareup.dinosaurs.Dinosaur#name' // Both roots and prunes in an external file rules 'rules.txt' kotlin { javaInterop true out \"${buildDir}/generated/custom\" } } The wire extension introduces the concept of compilation targets, such as kotlin and java , where each target has its own configuration properties. Multiple targets can be supplied, which benefits use cases such as migrating Java protos to Kotlin. New: Decouple the option of using Android annotations for nullability from the option of having messages implement Parcelable. New: Wire Moshi adapter for serializing proto JSON representation using the Moshi library. New: Implement support for custom enum types. New: Generate AndroidX nullability annotations instead of old support library annotations. New: Import JSR 305 and use it to mark nullability of public API. New: Allow inline multiline comments. New: Generate an empty class when a nested message is retained but its parent was pruned. New: Support rendering a ProtoFile to its schema. New: Support hexadecimal numeric literals. New: Allow custom types to be constrained with a \u2018with\u2019 clause. New: Generate a constructor which takes in a Message.Builder instead of all fields separately. New: Add location to the error message about unsupported group elements. New: Permit single files to be used on the proto path. Fix: Emit \u2018=\u2019 for syntax declaration. Fix: Don\u2019t crash when a comment has a dollar sign. Fix: Return subclass type instead of abstract parameterized type for newBuilder. Fix: Validate enum namespace in file context are unique. Version 2.2.0 \u00b6 2016-06-17 New: Support for map type in the schema, compiler, and runtime! New: AndroidMessage base class consolidates everything required for supporting Android and will now be used for generating code with --android . New: stream keyword in RPC definitions is now parsed and exposed in the schema. Fix: Nested types which are retained no longer cause their enclosing type to be retained. Instead, non-instantiable empty types will be generated for pruned enclosing types. Fix: Remove per-type Parcelable.Creator classes and instead use a single type which delegates to the message\u2019s ProtoAdapter . Fix: Retain information on redacted fields even when options were pruned. Fix: Do not generate code for handling null from list types (and now map types) which are guaranteed to never be null . Version 2.1.2 \u00b6 2016-04-15 Fix: Gson type adapter now deserializes JSON null literals to empty list for repeated fields. Version 2.1.1 \u00b6 2016-02-01 New: reserved keyword is now supported and enforced. Fix: Defer reflection-based lookup of enum method until first use to avoid class loading race conditions. Fix: Support single-quoted string literals. Fix: Adjacent string literals are not correctly concatenated. Version 2.1.0 \u00b6 2016-01-18 Empty lists of packed values were being encoded incorrectly. In Wire 2.0.x our message adapters incorrectly included empty lists for [packed=true] rather than omitting them. This is now fixed. New: Message.encode() to concisely encode a message. New: MessageAdapter.decode(ByteString) to decode a message from a byte string without an intermediate byte array. New: Wire now includes a sample code generation for service interfaces. Version 2.0.3 \u00b6 2016-01-04 New: ProtoAdapter.get overload which returns an adapter given an instance of a message. New: @Nullable annotations are emitted for optional fields when using --android . Fix: Remove the need for javac to generate synthetic accessor methods in the generated code. This results in smaller code size and less method references (for Android users). Version 2.0.2 \u00b6 2015-12-14 Fix: Exclude unknown fields when encoding JSON and drop unknown fields when parsing JSON. Fix: Ensure JSON encoding and decoding works in the default generation mode (not just --compact ) by always adding @WireField metadata to message fields. Fix: Update to JavaPoet 1.4 for more accurate generation of valid Java code. Version 2.0.1 \u00b6 2015-11-12 Fix: Do not emit case statements for aliased enum constant values. The first constant for a value will be returned when deserializing. Fix: Emit @Deprecated annotation on deprecated enum constants. Fix: Correctly prune dependencies of excluded message, enum, or service members. Previously the dependencies of an excluded member were retained despite the member itself being omitted. Version 2.0.0 \u00b6 2015-10-23 Wire 2 is a backwards-incompatible release. It makes breaking changes to the compiler, runtime, extensions, and generated code. These changes aren\u2019t made lightly as we\u2019ve endured the upgrade in our own projects! We believe the cost of migration is worth the benefits. We\u2019ve created the wire-schema library that models .proto schema definitions. This is a capable library that packs several neat features. You can load a Schema from .proto files located on the local file system, a ZIP or JAR file, or any java.nio.FileSystem like Jimfs . You can prune this schema with includes or excludes, allowing you to reuse .proto definitions with minimal code. And you can decode data directly from a schema: no code generation is necessary! We\u2019ve flattened extensions. Wire 2.0 combines the fields defined directly on messages with fields defined far away in extensions. In the generated code, extension fields look just like every other field! One limitation of this approach is that it\u2019s no longer possible to compile extensions separately from the messages they extend. For this reason we now recommend always generating all Wire code in a single step. We\u2019ve rearranged the runtime. Types related to the protocol buffers format are now prefixed Proto and types related to our implementation are prefixed Wire . To encode and decode messages you must first get an adapter either from the ADAPTER constant or from ProtoAdapter.get() . You no longer need a Wire instance! Runtime \u00b6 New ADAPTER constant on most messages gives access to encode & decode values. This replaces the encoding and decoding methods on Wire . Guard against null lists. Code that passes null to builder methods expecting a List used to accept that; now Wire throws a NullPointerException . Similarly list elements must also be non-null. New Message.newBuilder() API. This replaces the previous copy constructor on Builder . New: Message.withoutUnknownFields() strips unknown fields. Fix: Always throw ProtocolException when there are decoding problems. Fix: Stricter checking for oneof fields. Previously it was possible to create instances with multiple values set! Fix: Improve redacting of repeated fields. Fix: ProtoReader now silently unpacks packed values. Fix: ProtoReader doesn\u2019t return groups to callers. Schema & Java Generator \u00b6 The Java generator is now standalone. Use these APIs programmatically to build plugins without delegating to the command line interface. New: Prune schemas using includes and excludes. The IdentifierSet can be used to configure which types and members are retained and which are pruned. New: Encode and decode values directly from the schema. New: Improved error messages for validation. Fix: Strict imports. Fix: Detect and forbid conflicts on extension tags. Compiler \u00b6 New: Always use Wire\u2019s bundled descriptor.proto . Previously to define custom options you needed to import a potentially-inconsistent descriptor. New: Emit all types when no .proto files are explicitly specified. New: Generate code for encoding and decoding messages. The previous, reflection-based encoder and decoder are accessible with --compact . New: ServiceFactory has been removed. To generate code for your services, load a schema with wire-schema and then use a library like JavaPoet to generate your own code. The JavaGenerator class can be used to look up Java names of message types. New: Compiler will load all .proto files if none are explicitly specified. New: Load .proto files from ZIP and JAR files. New: The --android flag causes Wire messages to implement Parcelable . New: Support multiple --proto_path arguments New: The --named_files_only flag limits which .proto files yield .java files. This was the default in Wire 1.x. New: The --no_options flag has been deleted. Use --excludes=google.protobuf.* instead. Extensions \u00b6 Extensions have been flattened. Fix: Better field resolution for options. Fix: Extension fields must not be required . Version 1.8.0 \u00b6 2015-06-27 New: oneof support! Fix: Correct serialization of repeated unknown fields. Fix: Removed superfluous private modifier on enum constructor. Warning: The \u2018protoparser\u2019 library was updated to version 4.0. This changes the type passed to any ServiceWriter implementations. Version 1.7.0 \u00b6 2015-03-05 New: Messages implement Serializable . The serialized form follows protobuf encoding, so renaming fields is safe as long as tags are consistent. (Renaming classes is unsafe, however). Note that extension fields are deserialized as unknown fields. Version 1.6.1 \u00b6 2015-01-16 New: --quiet and --dry-run command-line arguments. Fix: Handle an extension registry with zero or only one item. Okio dependency bumped to 1.2.0. Version 1.6.0 \u00b6 2014-10-23 Fix: Correctly throw IOException when parsing bad input fails. Fix: Ensure emitted code references to Arrays.asList correctly compiles in some edge cases. \u2018 UNDEFINED \u2018 enum value has been removed. Version 1.5.2 \u00b6 2014-09-15 New: \u2018 UNDEFINED \u2018 enum value represents values that the generated code is unable to handle. New: Service writer implementation can now be specified on the command-line. Version 1.5.1 \u00b6 2014-06-18 New: Generate interface definition for a Service with a partial list of methods. Okio dependency bumped to 1.0.0. Version 1.5.0 \u00b6 2014-04-22 New: Options on enums and enum values are now supported. New: Options ending with .redacted on fields will omit values from toString . New: Redactor creates copies of messages with redacted fields omitted. Various internal serialization improvements and memory reduction. Okio dependency bumped to 0.9.0. Version 1.4.0 \u00b6 2014-04-22 Replace Wire\u2019s ByteString class with the one from Okio ( https://github.com/square/okio ). This is a breaking API change . Add a new static method Wire.parseFrom(okio.Source input, Class<M> messageClass) . Reimplement Wire\u2019s input handling to use Okio internally. Provide basic support for generating code from service declarations (see README.md). Improve deserialization performance. Fix a bug where no some extension dependencies were not detected. Version 1.3.3 \u00b6 2014-03-28 New: Support service declarations as roots. The request and response types of their methods will be included. Version 1.3.2 \u00b6 2014-03-27 Fix: Enum value duplicate check now correctly looks at names instead of values. Version 1.3.1 \u00b6 2014-03-25 New: Automatically add Maven plugin\u2019s generated source as a compilation root. Fix: Correct Maven plugin\u2019s \u2018no arguments\u2019 flag to work properly. Fix: Support extend declarations nested inside message types. Version 1.3.0 \u00b6 2014-03-21 New: Empty repeated fields are now initialized to an empty collection. New: Emit field options. Use --no_options flag to disable. New: @Deprecated is now added to fields and setters on the builder. New: Maven plugin for running the compiler as part of a build. Fix: Treat empty and null repeated fields the same in equals() and hashCode() . Note: This version is not backwards compatible with code generated from previous versions. Version 1.2.0 \u00b6 2013-11-01 New: --registry_class compiler argument emits a class with a list of extensions suitable for passing to the Wire constructor. Fix: Ensure all trailing whitespace is trimmed on documentation. Version 1.1.1 \u00b6 2013-10-23 Fix: Correct parsing and emission of multi-line documentation. Version 1.1.0 \u00b6 2013-10-22 New: Support for message options. New: Check for duplicate field tag numbers. New: Emit Javadoc on messages, enum values, and builder methods. Fix: Emit imports for extension fields and classes outside of package. Fix: Correctly generate sources for protos with the same basename. Fix: Do not generate default constants for message types. Fix: Avoid shadowing fields named \u201cresult\u201d, \u201cother\u201d, or \u201co\u201d. Version 1.0.1 \u00b6 2013-08-27 New: Support reading directly from InputStream . New: Add \u2018 other == this \u2018 shortcut in generated equals() methods. Version 1.0.0 \u00b6 2013-08-23 Initial version.","title":"Change Log"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#version-400-alpha18","text":"2021-11-22 Fix: In Java, rename instances to avoid field and class name conflicts. New: Wire should build and execute properly on Windows.","title":"Version 4.0.0-alpha.18"},{"location":"changelog/#version-400-alpha17","text":"2021-11-11 Fix: Validate enum constant uniqueness for the entire package. Fix: Compile Kotlin/JS with both LEGACY and IR compilers. Fix: Don\u2019t depend on moshi-kotlin in wire-moshi. This caused a transitive dependency on kotlin-reflect, which we neither needed nor wanted.","title":"Version 4.0.0-alpha.17"},{"location":"changelog/#version-400-alpha16","text":"2021-11-09 Fix: Don\u2019t generate invalid code when an enum constant is named name or ordinal . Fix: Deep copy metadata on GrpcCall.clone() . Fix: Support reporting errors in CustomHandlerBeta . Upgrade: Okio 3.0.0 . This is binary-incompatible with the Okio 3.0 alpha releases.","title":"Version 4.0.0-alpha.16"},{"location":"changelog/#version-371","text":"2021-11-03 Fix: Properly load schema located at root without packages.","title":"Version 3.7.1"},{"location":"changelog/#version-400-alpha15","text":"2021-10-21 Fix: Support for serializing builder-less Kotlin generated classes to JSON. Fix: Wire Gradle plugin tasks have been modernized with configuration caching support.","title":"Version 4.0.0-alpha.15"},{"location":"changelog/#version-400-alpha13","text":"2021-10-12 Fix: Memory fixes found with Address Sanitizer in Swift.","title":"Version 4.0.0-alpha.13"},{"location":"changelog/#version-400-alpha11","text":"2021-09-02 New: change the Gradle plugin so that (unstable) custom handlers can be configured with instance instead of with a class name. Note that releases 4.0.0-alpha.9 and 4.0.0-alpha.10 were published incorrectly and should not be used.","title":"Version 4.0.0-alpha.11"},{"location":"changelog/#version-400-alpha8","text":"2021-08-30 This release drops the -multiplatform suffix on Kotlin Multiplatform artifacts. All artifacts now share the same name (like com.squareup.wire:wire-runtime:4.0.0-alpha.8 ) for both Kotlin/JVM and Kotlin Multiplatform. New: Programmatic API to prune schemas. See Pruner in wire-schema. New: Expose the source .proto file at ProtoAdaper.sourceFile . This is null for built-in types and types generated prior to this release. Fix: Retain field order when emitting a schema as .proto files. Fix: Support Kotlin-generated annotations on Java fields. Fix: Locate files in the root package when importing.","title":"Version 4.0.0-alpha.8"},{"location":"changelog/#version-400-alpha7","text":"2021-08-09 Fix: Use correct type when referencing a custom adapter in Kotlin generated code. Fix: Handle writing/reading exceptions for duplex calls in Wire gRPC.","title":"Version 4.0.0-alpha.7"},{"location":"changelog/#version-400-alpha6","text":"2021-08-03 Fix: Explicitly defined Wire gRPC server generation as experimental: the feature isn\u2019t complete. Fix: Suppress deprecation warnings on generated enum\u2019s fromValue method in Kotlin. Fix: Use relative path sensitivity and file collection.","title":"Version 4.0.0-alpha.6"},{"location":"changelog/#version-400-alpha5","text":"2021-06-24 Kotlin + Java New: Generate Kotlin code whose members match the declaration order of the corresponding .proto files. In previous releases, generated members were sorted by kind (fields, oneofs), then by declaration order. With this update only declaration order is used. Note that this will change the encoded-bytes of these messages. This change is both forwards and backwards-compatible. Identical encoding of equal messages across Wire releases is typical but not guaranteed, and this is a rare release that changes that encoding. If you do cryptographic hashes on encoded proto messages, you will notice that the hashes are different in this release. Fix: Redact boxed OneOf fields. Fix: Don\u2019t crash encoding schemas when an option contains a repeated field, an enum, or a double. Fix: Be more aggressive about loading transitive files with SchemaLoader.loadExhaustively . Fix: Don\u2019t break task caching by using absolute paths in the Gradle plugin. Wire now uses project-relative paths in any attribute that is used as a cache key.","title":"Version 4.0.0-alpha.5"},{"location":"changelog/#version-400-alpha4","text":"2021-06-15 Kotlin + Java New: Define oneofName in @WireField . New: Option in SchemaLoader to exhaustively load imported files. By default we only load what\u2019s immediately necessary to generate code; this new option loads everything reachable into the schema.","title":"Version 4.0.0-alpha.4"},{"location":"changelog/#version-400-alpha3","text":"2021-06-03 Kotlin + Java New: Support for special float literals. New: Support for Android variants. New: Add \u2018nameSuffix\u2019 parameter for configuring generated service-class names in Kotlin. New: Support for glob syntax in srcJar includes. Fix: Redacted Kotlin scalars now respect nullability. Update: Update KotlinPoet to 1.8.0 . Bye: Drop support for emitKotlinxSerialization.","title":"Version 4.0.0-alpha.3"},{"location":"changelog/#version-400-alpha2","text":"2021-05-11 Kotlin + Java New: @WireRpc has a new sourceFile attribute. New: wire-reflector bundles gRPC\u2019s reflection.proto which it is built upon.","title":"Version 4.0.0-alpha.2"},{"location":"changelog/#version-400-alpha1","text":"2021-05-01 Kotlin + Java New: GrpcClient.Builder.minMessageToCompress() configures which messages are compressed. This will completely disable compression if the size is Long.MAX_VALUE . We\u2019ve seen problems where some Golang gRPC servers don\u2019t support compression; setting this to MAX_VALUE is necessary to interop with them. New: SchemaReflector is our initial implementation of the gRPC Server Reflection Protocol . Note that although we implement the business logic of gRPC reflection, we don\u2019t offer a gRPC server built into Wire. New: Support rpcRole = 'none' in the Gradle plugin to generate neither client nor server code. Fix: Generate @Deprecated annotations on deprecated messages, fields, enums, and enum constants. Fix: Update the Wire Gradle plugin to register generated .java sources with the Java compiler. Previously this was broken if the Kotlin plugin was installed. Fix: Use Gradle\u2019s logging mechanism to reduce output when Wire generates code. Fix: Update the Wire Gradle plugin to clear the output directory before generating code. This prevents the need to do a clean build after removing a message type. Fix: Permit values other than 0 and 1 when decoding protobuf-encoded booleans. Previously we threw an IOException for other values; now all non-zero values are true. Upgrade: Okio 3.0.0-alpha.3 . We now use Okio 3\u2019s FileSystem in SchemaLoader , which makes it easier to load .proto files from the classpath. Swift : New: Support Timestamp and Duration . Fix: Throw an error when encountering an unexpected ProtoReader.beginMessage() rather than calling fatalError() .","title":"Version 4.0.0-alpha.1"},{"location":"changelog/#version-370","text":"2021-03-25 New: srcProject(\":project-name\") makes it easier to depend on .proto files of other projects. Fix: Don\u2019t require source that .proto directories exist at Gradle plugin configuration time. This was preventing Wire from using other tasks\u2019 outputs as its inputs. Fix: Don\u2019t fail if options have a . prefix.","title":"Version 3.7.0"},{"location":"changelog/#version-361","text":"2021-03-09 Fix: The Wire Gradle plugin now supports Java only Android projects. Fix: In the Wire Gradle plugin, sourcePath will now include only protos defined with include if the option is present. It used to include all existing .proto files even if include was used. New: Full support Optional Int64 and UInt64 for JSONString in Swift.","title":"Version 3.6.1"},{"location":"changelog/#version-360","text":"2021-02-08 New: Automatically add a dependency when a protoPath or protoSource depends on a project. New: protoPath and protoSource dependencies are now not transitive by default. New: New protoLibrary option for the Wire Gradle plugin. Configuring a project as a protoLibrary will cause the generated .jar file to include .proto sources. New: Code generation for plain gRPC server. The Kotlin target now has a new grpcServerCompatible option which if set to true will generate gRPC server-compatible classes. New: Introduce GrpcException . New: Add GrpcMethod tag to the request. New: Adds redacting support for Moshi JSON adapters. New: Publish plugin marker for Gradle plugin. Fix: Escape square brackets in Kotlin generated code documentation. Fix: Improved proto parsing performance.","title":"Version 3.6.0"},{"location":"changelog/#version-350","text":"2020-10-27 New: Wire Gradle plugin improvements: A task is now created for each available sources (main, Android variants, etc). The wire-runtime dependency is automatically added. Generated code directories are automatically added into their module\u2019s source sets. New: Wire\u2019s proto parser now knows about oneOfOptions . New: Wire will throw when two enum constants are ambiguous, like ZERO and zero . New: Bytes options are not eligible anymore as annotation members. Fix: Optional fields in proto3 are now generated as nullable fields. Fix: JSON camel-casing is updated to fit latest protobuf specifications. Fix: Exception messages when gRPC fails have been improved. Fix: Allow ; as entry separator in option maps. Fix: Enum constants are now properly escaped when conflicting with keywords of their generated target platform. Fix: Update to KotlinPoet 1.7.2 which makes a lot of change in how Kotlin code is generated.","title":"Version 3.5.0"},{"location":"changelog/#version-340","text":"2020-09-24 New: Stop emitting enum constant options as fields for Kotlin. New: The Wire Gradle plugin task is now cacheable. New: New GrpcCall function to help implement fakes. New: Change GrpcStreamingCall.execute() to support structured concurrency.","title":"Version 3.4.0"},{"location":"changelog/#version-330","text":"2020-09-14 New: Proto3 support! This includes the new behaviors, the new types, and the JSON. New: Swift support for proto2 schemas. The details are in our blog post . New: Wire will now throw an error when: two generated files end up overriding each other, imports form a cycle, packages form a cycle. This can be turned off with the flag permitPackageCycles , an option within the source set cannot be resolved, there are name duplications of members in a message, or of rpcs in a service, a map is used as an extension. New: Support for the json_name pseudo option. New: The wire_package file option allows one to set the JVM package where classes generated from the concerned file will be placed. wire_package takes precedence over java_package . New: Lists and maps in Kotlin generated code are now immutable. New: Support UTF-8 with BOM in proto files. New: wire.since and wire.until have been renamed with the prefix constant_ for EnumValueOptions . New: Wire generates 1) annotations for options which 2) gets assigned to the generated code where appropriate. Both behavior can be turn on or off via the flags: emitDeclaredOptions : True to emit types for options declared on messages, fields, etc. Default to true, emitAppliedOptions : True to emit annotations for options applied on messages, fields, etc. Default to false. Fix: Recursive map values. Fix: Long expressions in equals and encodedSize functions.","title":"Version 3.3.0"},{"location":"changelog/#version-322","text":"2020-05-15 Fix: JSON serialization correctly emits all values.","title":"Version 3.2.2"},{"location":"changelog/#version-321","text":"2020-05-02 New: onlyVersion option on the Wire Gradle plugin to target a unique version. By and large, service code that supports many clients would target ranges via sinceVersion and untilVersion , while client code would target a unique version via onlyVersion . New: Support for optional fields in Proto3. Fix: Restored the GrpcClient.create API to create implementations for gRPC interfaces.","title":"Version 3.2.1"},{"location":"changelog/#version-320","text":"2020-04-23 New: wire.since and wire.until options on members and enum values. You can prune fields or constants using these two options. When generating code with the Wire Gradle plugin, define sinceVersion and/or untilVersion to scope the generated code. New: Messages\u2019 toString method on Kotlin and Java now escape string values for easy parsing. Fix: Link the entire descriptor.proto every time when building the Schema . Fix: Properly handle members named after keywords of the target language for both Java and Kotlin. Fix: Use the declared name for keys in JSON when emitting/reading keyword named members. Fix: Generated Kotlin code is malformed for long identifiers. Fix: Make the Wire Gradle plugin compatible with instant execution.","title":"Version 3.2.0"},{"location":"changelog/#version-310","text":"2020-02-06 This release includes major non-backwards-compatible API changes to the wire-schema module. This will break tools that use Wire\u2019s schema modeling as a standalone library. We are making big changes to this component and we sacrificed API compatibility to accelerate these improvements. New: proto { ... } target in the Wire Gradle plugin. Use this to perform basic source code transformations on collections of .proto files. We use it to prune large collections of protos to just the subset used by the application. Fix: Support all forms of reserved extensions, such as extensions 1, 3 to 5, 7; . Fix: Don\u2019t re-generate source files when their .proto files haven\u2019t changed. New: includes , excludes , root , and prune give precedence to the most precise rule. Previously excludes always took precedence over includes , and prune always took precedence over root . Fix: Generate non-instantiable class for enclosing types in Kotlin. These are emitted when a nested type is retained but its enclosing type is pruned. Fix: Do not fail to build when the profile cannot find a dependency.","title":"Version 3.1.0"},{"location":"changelog/#version-303","text":"2019-12-23 Starting with this version the Wire Maven plugin is no longer maintained and has been removed from the repository. New: Support for custom options in Kotlin. New: Kotlin 1.3.61. New: Add support for custom targets in WireRun and the Gradle plugin. New: Improve schema evaluation algorithm when loading separate sourcePath and protoPath . New: Lazy loading of protoPath contents. New: Make it possible to customize Gradle plugin\u2019s configurations. New: Make it possible to customize Gradle plugin\u2019s generateProtos task. Fix: Use correct ProtoAdapter for packed fields in Kotlin. Fix: Properly handle name clashes between fields and enclosing types. Fix: Preserve the package name on files loaded from protoPath . Fix: ProtoPruner: Properly evaluate Pruner\u2019s reachable objects. Fix: ProtoPruner: Ensure --excludes properly prunes options. Fix: ProtoPruner: Keep used ServiceOptions and MethodOptions when pruning.","title":"Version 3.0.3"},{"location":"changelog/#version-302","text":"2019-11-22 Fix: Generate correct unknownFields code if a message field\u2019s name is a Kotlin keyword. Fix: Properly handle unknown enum values in Kotlin. Fix: ProtoPruner: retain used extends. Fix: ProtoPruner: retain only used imports. Fix: ProtoPruner: use NewSchemaLoader that correctly loads google.protobuf.descriptor. Fix: ProtoPruner: print default values for scalar types for proto target within the options. Fix: ProtoPruner: fix handling of options. Fix: ProtoPruner: print default values for enums.","title":"Version 3.0.2"},{"location":"changelog/#version-301","text":"2019-10-18 Fix: Use the correct adapter path for gRPC endpoints that customize the Java package. Fix: Preserve documentation in generated services. Fix: Fail to generate code if the source directory doesn\u2019t exist. Fix: Make Kotlin consistent with Java for unknown enum constants. We now treat these as unknown fields rather than failing to decode the enclosing message.","title":"Version 3.0.1"},{"location":"changelog/#version-300","text":"2019-10-07 Update: All gRPC networking calls are encoded in gzip.","title":"Version 3.0.0"},{"location":"changelog/#version-300-rc03","text":"2019-10-04 Fix: Update dependency to a stable version, 2.4.1 of Okio.","title":"Version 3.0.0-rc03"},{"location":"changelog/#version-300-rc02","text":"2019-10-01","title":"Version 3.0.0-rc02"},{"location":"changelog/#kotlin","text":"Fix: Nullify other oneof fields in Builder setters in Kotlin interop. Fix: Use unknownFields in hashCode() . Fix: Remove withoutUnknownFields() from Kotlin.","title":"Kotlin"},{"location":"changelog/#grpc","text":"Update: Total rewrite of the generated interfaces for clients: Introduce two interfaces, GrpcCall for simple RPCs, and GrpcStreamingCall fox duplex ones. Both will provide blocking and suspending API, including a reference to the underlying OkHttp Call object and its timeout. Fix: Send stream cancels from clients.","title":"gRPC"},{"location":"changelog/#misc","text":"New: Changes printing of options and enums: No empty lines between options and fields for enums. Print options on new lines only when more than one. Fix: Don\u2019t cache Message\u2019s hash code on Native. Fix: Fix handling of map values in FieldBinding . Fix: Fix import fails on windows due to path separator. Fix: Don\u2019t emit proto2 sources for proto3 syntax.","title":"Misc"},{"location":"changelog/#version-300-rc01","text":"2019-08-02","title":"Version 3.0.0-rc01"},{"location":"changelog/#compiler-gradle-plugin","text":"New: Support includes on Maven coordinate dependencies. New: Track includes separately for source vs proto paths. New: Follow symlinks when building. New: Change the Gradle plugin to track targets as a list. New: Includes and Excludes for Wire targets. New: Print errors on ambiguous and missing imports. Fix: Fix a bug where protopath Maven resources weren\u2019t working. Fix: Don\u2019t reuse source dependencies as protopath dependencies. Fix: Fix equals() implementation for messages with no fields.","title":"Compiler + Gradle plugin"},{"location":"changelog/#kotlin_1","text":"New: Move Wire.kt into jvmMain to discourage its use in common Kotlin code. New: Make Message.adapter a val . New: Optimize decode() code for protos with no fields. New: Update supported Native platforms. New: Make Message.unknownFields property non-nullable. New: Make Message.unknownFields a val . Fix: Don\u2019t use KClass.simpleName to avoid needing kotlin-reflect dependency. Fix: Use kotlin.UnsupportedOperationException in generated code.","title":"Kotlin"},{"location":"changelog/#grpc_1","text":"New: Introduce MessageSource and MessageSink interfaces in wire-runtime . New: Honor Java package names in Wire gRPC services. New: Make PipeDuplexRequestBody internal. Fix: Workaround for @Generated annotation on Java 9+. Fix: Fix types for blocking APIs.","title":"gRPC"},{"location":"changelog/#misc_1","text":"Fix: Fix deserializing null values in Gson adapter. Fix: Change wire-runtime artifact names to preserve 2.x compatibility.","title":"Misc"},{"location":"changelog/#version-300-alpha03","text":"2019-06-22 Similar to alpha02, but with proper wire-runtime multiplatform artifacts.","title":"Version 3.0.0-alpha03"},{"location":"changelog/#version-300-alpha02","text":"2019-06-21 New: Experimental multiplatform runtime. Starting with this version, wire-runtime is published as a multiplatform Kotlin artifact. While the JVM artifact is binary- and behavior-compatible with 3.0.0-alpha01, artifacts for other platforms may not work correctly at this point. The artifact name for the JVM artifact has been changed to wire-runtime-jvm : now, in order to depend on the multiplatform runtime, use the following Gradle dependency declaration: api \"com.squareup.wire:wire-runtime:3.0.0-alpha02\" and if you want to depend on the JVM artifact only, use the following declaration: api \"com.squareup.wire:wire-runtime-jvm:3.0.0-alpha02\" New: Generate RPCs as Single Abstract Methods. New: Add \u201csingleMethod\u201d Gradle plugin configuration for services. New: Add \u201cblockingServices\u201d Gradle plugin configuration for services. New: Support packageless services code generation. New: Remove sealed classes-based oneof implementation. New: Don\u2019t generate a Builder for non-interop Kotlin messages. Fix: Kotlin Generator correctly generates code for Protobuf services. Fix: Improved formatting of generated Kotlin code. Fix: Generate correct adapter names for WireField annotation. Fix: Generate labels for WireField annotation. Fix: Wrap oneof error message properly.","title":"Version 3.0.0-alpha02"},{"location":"changelog/#version-300-alpha01","text":"2019-03-14 New: Kotlin Generator Wire 3 can generate Kotlin data classes. To enable this feature via the command line API, pass in the --kotlin_out parameter that should specify the output directory for the generated *.kt files. Given the following simple proto: message Person { required string name = 1 ; required int32 id = 2 ; optional string email = 3 ; } the generated Kotlin code will look like the following: data class Person ( @field : WireField ( tag = 1 , adapter = \"com.squareup.wire.ProtoAdapter#STRING\" ) val name : String , @field : WireField ( tag = 2 , adapter = \"com.squareup.wire.ProtoAdapter#INT32\" ) val id : Int , @field : WireField ( tag = 3 , adapter = \"com.squareup.wire.ProtoAdapter#STRING\" ) val email : String? = null , val unknownFields : ByteString = ByteString . EMPTY ) : Message < Person , Person . Builder > ( ADAPTER , unknownFields ) { companion object { @JvmField val ADAPTER : ProtoAdapter < Person > = ... // code omitted for brevity The copy() method of a data class replaces most usages of the builder. If your code relies on the Builder , you can enable full Builder generation by passing the --java_interop parameter to the compiler. New: gRPC support In addition to generating Kotlin code from proto messages, Wire can now generate code for gRPC endpoints. Here\u2019s an example schema: service RouteGuide { // A simple RPC. // // Obtains the feature at a given position. // // A feature with an empty name is returned if there's no feature at the given // position. rpc GetFeature ( Point ) returns ( Feature ) {} } The generated code will look like the following (message protos, referenced by the schema, are omitted): interface RouteGuide : Service { @WireRpc ( path = \"/routeguide.RouteGuide/GetFeature\" , requestAdapter = \"routeguide.Point#ADAPTER\" , responseAdapter = \"routeguide.Feature#ADAPTER\" ) suspend fun GetFeature ( request : Point ): Feature } All four gRPC modes are supported: the generated code uses suspendable functions to implement non-blocking asynchronous execution. In streaming modes, ReceiveChannel and SendChannel are used to listen to asynchronous data in a non-blocking fashion. This feature works out of the box in Wire 3 compiler as long as the input file contains a gRPC schema. New: Gradle plugin Here\u2019s an example Gradle configuration: apply plugin: 'com.squareup.wire' wire { // Keeps only 'Dinosaur#name' as the root of the object graph roots 'squareup.dinosaurs.Dinosaur#name' // Keeps all fields, except 'name', in 'Dinosaur' prunes 'squareup.dinosaurs.Dinosaur#name' // Both roots and prunes in an external file rules 'rules.txt' kotlin { javaInterop true out \"${buildDir}/generated/custom\" } } The wire extension introduces the concept of compilation targets, such as kotlin and java , where each target has its own configuration properties. Multiple targets can be supplied, which benefits use cases such as migrating Java protos to Kotlin. New: Decouple the option of using Android annotations for nullability from the option of having messages implement Parcelable. New: Wire Moshi adapter for serializing proto JSON representation using the Moshi library. New: Implement support for custom enum types. New: Generate AndroidX nullability annotations instead of old support library annotations. New: Import JSR 305 and use it to mark nullability of public API. New: Allow inline multiline comments. New: Generate an empty class when a nested message is retained but its parent was pruned. New: Support rendering a ProtoFile to its schema. New: Support hexadecimal numeric literals. New: Allow custom types to be constrained with a \u2018with\u2019 clause. New: Generate a constructor which takes in a Message.Builder instead of all fields separately. New: Add location to the error message about unsupported group elements. New: Permit single files to be used on the proto path. Fix: Emit \u2018=\u2019 for syntax declaration. Fix: Don\u2019t crash when a comment has a dollar sign. Fix: Return subclass type instead of abstract parameterized type for newBuilder. Fix: Validate enum namespace in file context are unique.","title":"Version 3.0.0-alpha01"},{"location":"changelog/#version-220","text":"2016-06-17 New: Support for map type in the schema, compiler, and runtime! New: AndroidMessage base class consolidates everything required for supporting Android and will now be used for generating code with --android . New: stream keyword in RPC definitions is now parsed and exposed in the schema. Fix: Nested types which are retained no longer cause their enclosing type to be retained. Instead, non-instantiable empty types will be generated for pruned enclosing types. Fix: Remove per-type Parcelable.Creator classes and instead use a single type which delegates to the message\u2019s ProtoAdapter . Fix: Retain information on redacted fields even when options were pruned. Fix: Do not generate code for handling null from list types (and now map types) which are guaranteed to never be null .","title":"Version 2.2.0"},{"location":"changelog/#version-212","text":"2016-04-15 Fix: Gson type adapter now deserializes JSON null literals to empty list for repeated fields.","title":"Version 2.1.2"},{"location":"changelog/#version-211","text":"2016-02-01 New: reserved keyword is now supported and enforced. Fix: Defer reflection-based lookup of enum method until first use to avoid class loading race conditions. Fix: Support single-quoted string literals. Fix: Adjacent string literals are not correctly concatenated.","title":"Version 2.1.1"},{"location":"changelog/#version-210","text":"2016-01-18 Empty lists of packed values were being encoded incorrectly. In Wire 2.0.x our message adapters incorrectly included empty lists for [packed=true] rather than omitting them. This is now fixed. New: Message.encode() to concisely encode a message. New: MessageAdapter.decode(ByteString) to decode a message from a byte string without an intermediate byte array. New: Wire now includes a sample code generation for service interfaces.","title":"Version 2.1.0"},{"location":"changelog/#version-203","text":"2016-01-04 New: ProtoAdapter.get overload which returns an adapter given an instance of a message. New: @Nullable annotations are emitted for optional fields when using --android . Fix: Remove the need for javac to generate synthetic accessor methods in the generated code. This results in smaller code size and less method references (for Android users).","title":"Version 2.0.3"},{"location":"changelog/#version-202","text":"2015-12-14 Fix: Exclude unknown fields when encoding JSON and drop unknown fields when parsing JSON. Fix: Ensure JSON encoding and decoding works in the default generation mode (not just --compact ) by always adding @WireField metadata to message fields. Fix: Update to JavaPoet 1.4 for more accurate generation of valid Java code.","title":"Version 2.0.2"},{"location":"changelog/#version-201","text":"2015-11-12 Fix: Do not emit case statements for aliased enum constant values. The first constant for a value will be returned when deserializing. Fix: Emit @Deprecated annotation on deprecated enum constants. Fix: Correctly prune dependencies of excluded message, enum, or service members. Previously the dependencies of an excluded member were retained despite the member itself being omitted.","title":"Version 2.0.1"},{"location":"changelog/#version-200","text":"2015-10-23 Wire 2 is a backwards-incompatible release. It makes breaking changes to the compiler, runtime, extensions, and generated code. These changes aren\u2019t made lightly as we\u2019ve endured the upgrade in our own projects! We believe the cost of migration is worth the benefits. We\u2019ve created the wire-schema library that models .proto schema definitions. This is a capable library that packs several neat features. You can load a Schema from .proto files located on the local file system, a ZIP or JAR file, or any java.nio.FileSystem like Jimfs . You can prune this schema with includes or excludes, allowing you to reuse .proto definitions with minimal code. And you can decode data directly from a schema: no code generation is necessary! We\u2019ve flattened extensions. Wire 2.0 combines the fields defined directly on messages with fields defined far away in extensions. In the generated code, extension fields look just like every other field! One limitation of this approach is that it\u2019s no longer possible to compile extensions separately from the messages they extend. For this reason we now recommend always generating all Wire code in a single step. We\u2019ve rearranged the runtime. Types related to the protocol buffers format are now prefixed Proto and types related to our implementation are prefixed Wire . To encode and decode messages you must first get an adapter either from the ADAPTER constant or from ProtoAdapter.get() . You no longer need a Wire instance!","title":"Version 2.0.0"},{"location":"changelog/#runtime","text":"New ADAPTER constant on most messages gives access to encode & decode values. This replaces the encoding and decoding methods on Wire . Guard against null lists. Code that passes null to builder methods expecting a List used to accept that; now Wire throws a NullPointerException . Similarly list elements must also be non-null. New Message.newBuilder() API. This replaces the previous copy constructor on Builder . New: Message.withoutUnknownFields() strips unknown fields. Fix: Always throw ProtocolException when there are decoding problems. Fix: Stricter checking for oneof fields. Previously it was possible to create instances with multiple values set! Fix: Improve redacting of repeated fields. Fix: ProtoReader now silently unpacks packed values. Fix: ProtoReader doesn\u2019t return groups to callers.","title":"Runtime"},{"location":"changelog/#schema-java-generator","text":"The Java generator is now standalone. Use these APIs programmatically to build plugins without delegating to the command line interface. New: Prune schemas using includes and excludes. The IdentifierSet can be used to configure which types and members are retained and which are pruned. New: Encode and decode values directly from the schema. New: Improved error messages for validation. Fix: Strict imports. Fix: Detect and forbid conflicts on extension tags.","title":"Schema &amp; Java Generator"},{"location":"changelog/#compiler","text":"New: Always use Wire\u2019s bundled descriptor.proto . Previously to define custom options you needed to import a potentially-inconsistent descriptor. New: Emit all types when no .proto files are explicitly specified. New: Generate code for encoding and decoding messages. The previous, reflection-based encoder and decoder are accessible with --compact . New: ServiceFactory has been removed. To generate code for your services, load a schema with wire-schema and then use a library like JavaPoet to generate your own code. The JavaGenerator class can be used to look up Java names of message types. New: Compiler will load all .proto files if none are explicitly specified. New: Load .proto files from ZIP and JAR files. New: The --android flag causes Wire messages to implement Parcelable . New: Support multiple --proto_path arguments New: The --named_files_only flag limits which .proto files yield .java files. This was the default in Wire 1.x. New: The --no_options flag has been deleted. Use --excludes=google.protobuf.* instead.","title":"Compiler"},{"location":"changelog/#extensions","text":"Extensions have been flattened. Fix: Better field resolution for options. Fix: Extension fields must not be required .","title":"Extensions"},{"location":"changelog/#version-180","text":"2015-06-27 New: oneof support! Fix: Correct serialization of repeated unknown fields. Fix: Removed superfluous private modifier on enum constructor. Warning: The \u2018protoparser\u2019 library was updated to version 4.0. This changes the type passed to any ServiceWriter implementations.","title":"Version 1.8.0"},{"location":"changelog/#version-170","text":"2015-03-05 New: Messages implement Serializable . The serialized form follows protobuf encoding, so renaming fields is safe as long as tags are consistent. (Renaming classes is unsafe, however). Note that extension fields are deserialized as unknown fields.","title":"Version 1.7.0"},{"location":"changelog/#version-161","text":"2015-01-16 New: --quiet and --dry-run command-line arguments. Fix: Handle an extension registry with zero or only one item. Okio dependency bumped to 1.2.0.","title":"Version 1.6.1"},{"location":"changelog/#version-160","text":"2014-10-23 Fix: Correctly throw IOException when parsing bad input fails. Fix: Ensure emitted code references to Arrays.asList correctly compiles in some edge cases. \u2018 UNDEFINED \u2018 enum value has been removed.","title":"Version 1.6.0"},{"location":"changelog/#version-152","text":"2014-09-15 New: \u2018 UNDEFINED \u2018 enum value represents values that the generated code is unable to handle. New: Service writer implementation can now be specified on the command-line.","title":"Version 1.5.2"},{"location":"changelog/#version-151","text":"2014-06-18 New: Generate interface definition for a Service with a partial list of methods. Okio dependency bumped to 1.0.0.","title":"Version 1.5.1"},{"location":"changelog/#version-150","text":"2014-04-22 New: Options on enums and enum values are now supported. New: Options ending with .redacted on fields will omit values from toString . New: Redactor creates copies of messages with redacted fields omitted. Various internal serialization improvements and memory reduction. Okio dependency bumped to 0.9.0.","title":"Version 1.5.0"},{"location":"changelog/#version-140","text":"2014-04-22 Replace Wire\u2019s ByteString class with the one from Okio ( https://github.com/square/okio ). This is a breaking API change . Add a new static method Wire.parseFrom(okio.Source input, Class<M> messageClass) . Reimplement Wire\u2019s input handling to use Okio internally. Provide basic support for generating code from service declarations (see README.md). Improve deserialization performance. Fix a bug where no some extension dependencies were not detected.","title":"Version 1.4.0"},{"location":"changelog/#version-133","text":"2014-03-28 New: Support service declarations as roots. The request and response types of their methods will be included.","title":"Version 1.3.3"},{"location":"changelog/#version-132","text":"2014-03-27 Fix: Enum value duplicate check now correctly looks at names instead of values.","title":"Version 1.3.2"},{"location":"changelog/#version-131","text":"2014-03-25 New: Automatically add Maven plugin\u2019s generated source as a compilation root. Fix: Correct Maven plugin\u2019s \u2018no arguments\u2019 flag to work properly. Fix: Support extend declarations nested inside message types.","title":"Version 1.3.1"},{"location":"changelog/#version-130","text":"2014-03-21 New: Empty repeated fields are now initialized to an empty collection. New: Emit field options. Use --no_options flag to disable. New: @Deprecated is now added to fields and setters on the builder. New: Maven plugin for running the compiler as part of a build. Fix: Treat empty and null repeated fields the same in equals() and hashCode() . Note: This version is not backwards compatible with code generated from previous versions.","title":"Version 1.3.0"},{"location":"changelog/#version-120","text":"2013-11-01 New: --registry_class compiler argument emits a class with a list of extensions suitable for passing to the Wire constructor. Fix: Ensure all trailing whitespace is trimmed on documentation.","title":"Version 1.2.0"},{"location":"changelog/#version-111","text":"2013-10-23 Fix: Correct parsing and emission of multi-line documentation.","title":"Version 1.1.1"},{"location":"changelog/#version-110","text":"2013-10-22 New: Support for message options. New: Check for duplicate field tag numbers. New: Emit Javadoc on messages, enum values, and builder methods. Fix: Emit imports for extension fields and classes outside of package. Fix: Correctly generate sources for protos with the same basename. Fix: Do not generate default constants for message types. Fix: Avoid shadowing fields named \u201cresult\u201d, \u201cother\u201d, or \u201co\u201d.","title":"Version 1.1.0"},{"location":"changelog/#version-101","text":"2013-08-27 New: Support reading directly from InputStream . New: Add \u2018 other == this \u2018 shortcut in generated equals() methods.","title":"Version 1.0.1"},{"location":"changelog/#version-100","text":"2013-08-23 Initial version.","title":"Version 1.0.0"},{"location":"code_of_conduct/","text":"Open Source Code of Conduct \u00b6 At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter. Diversity Statement \u00b6 We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities. Reporting Issues \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below. Thanks \u00b6 Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work. Reporting Guide \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Code of Conduct"},{"location":"code_of_conduct/#open-source-code-of-conduct","text":"At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.","title":"Open Source Code of Conduct"},{"location":"code_of_conduct/#diversity-statement","text":"We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.","title":"Diversity Statement"},{"location":"code_of_conduct/#reporting-issues","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below.","title":"Reporting Issues"},{"location":"code_of_conduct/#thanks","text":"Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work.","title":"Thanks"},{"location":"code_of_conduct/#reporting-guide","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Reporting Guide"},{"location":"contributing/","text":"Contributing \u00b6 Keeping the project small and stable limits our ability to accept new contributors. We are not seeking new committers at this time, but some small contributions are welcome. If you\u2019ve found a security problem, please follow our bug bounty program. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. Before code can be accepted all contributors must complete our Individual Contributor License Agreement (CLA) . Code Contributions \u00b6 Get working code on a personal branch with tests passing before you submit a PR: ./gradlew clean check Please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Contribute code changes through GitHub by forking the repository and sending a pull request. We squash all pull requests on merge. Committer\u2019s Guides \u00b6 Releasing","title":"Contributing"},{"location":"contributing/#contributing","text":"Keeping the project small and stable limits our ability to accept new contributors. We are not seeking new committers at this time, but some small contributions are welcome. If you\u2019ve found a security problem, please follow our bug bounty program. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. Before code can be accepted all contributors must complete our Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"contributing/#code-contributions","text":"Get working code on a personal branch with tests passing before you submit a PR: ./gradlew clean check Please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Contribute code changes through GitHub by forking the repository and sending a pull request. We squash all pull requests on merge.","title":"Code Contributions"},{"location":"contributing/#committers-guides","text":"Releasing","title":"Committer's Guides"},{"location":"releasing/","text":"Releasing \u00b6 Prerequisite: Sonatype (Maven Central) Account \u00b6 Create an account on the Sonatype issues site . Ask an existing publisher to open an issue requesting publishing permissions for com.squareup projects. Cutting a JVM Release \u00b6 Update CHANGELOG.md . Set versions: export RELEASE_VERSION=X.Y.Z export NEXT_VERSION=X.Y.Z-SNAPSHOT Update versions: sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\ `find . -name \"gradle.properties\"` sed -i \"\" \\ \"s/\\\"com.squareup.wire:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"com.squareup.wire:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -name \"README.md\"` sed -i \"\" \\ \"s/\\<version\\>\\([^<]*\\)\\<\\/version\\>/\\<version\\>$RELEASE_VERSION\\<\\/version\\>/g\" \\ `find . -name \"README.md\"` Tag the release and push to GitHub. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a $RELEASE_VERSION -m \"Version $RELEASE_VERSION\" git push && git push --tags Wait for GitHub Actions to start building the release. Prepare for ongoing development and push to GitHub. sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\ `find . -name \"gradle.properties\"` git commit -am \"Prepare next development version.\" git push Wait for GitHub Actions to build and publish releases for both Windows and Non-Windows. Visit Sonatype Nexus to promote (close then release) the releases. Or drop it if there is a problem! Deploy the documentation website. ./deploy_website.sh Publishing the Swift CocoaPods \u00b6 There are two Podspecs to publish to CocoaPods: the Swift Wire runtime and the Swift Wire compiler. The same version number should be used for both. CocoaPods are published to the trunk repo, which is the main public repo for all CocoaPods. If you have not published Wire before then you\u2019ll need to get set up to publish to trunk , and be added as a publisher for the Wire Podspecs. Setting the Version \u00b6 When publishing a new version, two things must be done: 1. The version must be tagged in Git. So if you\u2019re publishing version 4.0.0-alpha1 , then you\u2019d check out the SHA you want to publish and run: git tag 4.0.0-alpha1 git push origin refs/tags/4.0.0-alpha1 The version being published needs to be passed into the Podspecs. This is done by setting the POD_VERSION environment variable: export POD_VERSION=4.0.0-alpha1 If publishing a release version (like 4.0.0 rather than 4.0.0-alpha1 ) then setting the POD_VERSION is optional and it will be pulled automatically from wire-library/gradle.properties . Publishing the Podspecs \u00b6 After setting the version as described above, you can publish the two Podspecs by doing: # Tests are currently failing, thus --skip-tests is required pod trunk push Wire.podspec --skip-tests and pod trunk push WireCompiler.podspec","title":"Releasing"},{"location":"releasing/#releasing","text":"","title":"Releasing"},{"location":"releasing/#prerequisite-sonatype-maven-central-account","text":"Create an account on the Sonatype issues site . Ask an existing publisher to open an issue requesting publishing permissions for com.squareup projects.","title":"Prerequisite: Sonatype (Maven Central) Account"},{"location":"releasing/#cutting-a-jvm-release","text":"Update CHANGELOG.md . Set versions: export RELEASE_VERSION=X.Y.Z export NEXT_VERSION=X.Y.Z-SNAPSHOT Update versions: sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\ `find . -name \"gradle.properties\"` sed -i \"\" \\ \"s/\\\"com.squareup.wire:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"com.squareup.wire:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -name \"README.md\"` sed -i \"\" \\ \"s/\\<version\\>\\([^<]*\\)\\<\\/version\\>/\\<version\\>$RELEASE_VERSION\\<\\/version\\>/g\" \\ `find . -name \"README.md\"` Tag the release and push to GitHub. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a $RELEASE_VERSION -m \"Version $RELEASE_VERSION\" git push && git push --tags Wait for GitHub Actions to start building the release. Prepare for ongoing development and push to GitHub. sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\ `find . -name \"gradle.properties\"` git commit -am \"Prepare next development version.\" git push Wait for GitHub Actions to build and publish releases for both Windows and Non-Windows. Visit Sonatype Nexus to promote (close then release) the releases. Or drop it if there is a problem! Deploy the documentation website. ./deploy_website.sh","title":"Cutting a JVM Release"},{"location":"releasing/#publishing-the-swift-cocoapods","text":"There are two Podspecs to publish to CocoaPods: the Swift Wire runtime and the Swift Wire compiler. The same version number should be used for both. CocoaPods are published to the trunk repo, which is the main public repo for all CocoaPods. If you have not published Wire before then you\u2019ll need to get set up to publish to trunk , and be added as a publisher for the Wire Podspecs.","title":"Publishing the Swift CocoaPods"},{"location":"releasing/#setting-the-version","text":"When publishing a new version, two things must be done: 1. The version must be tagged in Git. So if you\u2019re publishing version 4.0.0-alpha1 , then you\u2019d check out the SHA you want to publish and run: git tag 4.0.0-alpha1 git push origin refs/tags/4.0.0-alpha1 The version being published needs to be passed into the Podspecs. This is done by setting the POD_VERSION environment variable: export POD_VERSION=4.0.0-alpha1 If publishing a release version (like 4.0.0 rather than 4.0.0-alpha1 ) then setting the POD_VERSION is optional and it will be pulled automatically from wire-library/gradle.properties .","title":"Setting the Version"},{"location":"releasing/#publishing-the-podspecs","text":"After setting the version as described above, you can publish the two Podspecs by doing: # Tests are currently failing, thus --skip-tests is required pod trunk push Wire.podspec --skip-tests and pod trunk push WireCompiler.podspec","title":"Publishing the Podspecs"},{"location":"security/","text":"Security Policy \u00b6 Supported Versions \u00b6 Version Supported 3.x \u2705 2.x 1.x Reporting a Vulnerability \u00b6 Square recognizes the important contributions the security research community can make. We therefore encourage reporting security issues with the code contained in this repository. If you believe you have discovered a security vulnerability, please follow the guidelines at https://bugcrowd.com/squareopensource","title":"Security"},{"location":"security/#security-policy","text":"","title":"Security Policy"},{"location":"security/#supported-versions","text":"Version Supported 3.x \u2705 2.x 1.x","title":"Supported Versions"},{"location":"security/#reporting-a-vulnerability","text":"Square recognizes the important contributions the security research community can make. We therefore encourage reporting security issues with the code contained in this repository. If you believe you have discovered a security vulnerability, please follow the guidelines at https://bugcrowd.com/squareopensource","title":"Reporting a Vulnerability"},{"location":"wire_compiler/","text":"Wire Compiler & Gradle Plugin \u00b6 Wire has two key components: a compiler that generates Kotlin and Java code at build time, and a runtime library that supports the generated code when your program executes. The compiler is very configurable; this guide explains its features and their use. Getting Started \u00b6 The best way to configure and execute the Wire compiler is via our Gradle plugin. It requires Gradle 5.5 or newer. A typical project has .proto files in the standard src/main/proto directory. src/ main/ proto/ com/ example/ pizza/ pizza_delivery.proto pizza.proto sales/ price.proto store.proto geo/ address.proto country.proto kotlin/ com/ example/ pizza/ PizzaApp.kt test/ kotlin/ com/ example/ pizza/ PizzaAppTest.kt build.gradle Because this project uses the default configuration, plugin setup is easy. Just a simple block in build.gradle , Using plugin application: buildscript { repositories { mavenCentral () } dependencies { classpath 'com.squareup.wire:wire-gradle-plugin:<version>' } } apply plugin: 'com.squareup.wire' wire { kotlin {} } Using the plugins DSL: plugins { id 'application' id 'org.jetbrains.kotlin.jvm' id 'com.squareup.wire' } wire { kotlin {} } The plugin will read the .proto schema definitions, validate them, link them, and generate Kotlin code. It uses KotlinPoet internally to generate compact and legible source files. Wire will generate files in build/generated/source/wire . It\u2019ll also register this directory as a source directory for the project so the generated sources are compiled by the Kotlin compiler. Replace kotlin with java to generate Java sources instead. Inputs and Outputs \u00b6 Wire can pull source .proto schema definitions from a local directory, a local .jar file, or an external artifact specified with Maven coordinates . wire { sourcePath { srcDir 'src/main/protos' } sourcePath { srcJar 'lib/pizza-protos.jar' } sourcePath { srcJar 'com.example.pizza:pizza-protos:1.0.0' } ... } If your resource or directory contains more .proto files than you need to compile you can constrain the inputs to specific files: wire { sourcePath { srcDir 'src/main/protos' include 'com/example/pizza/pizza_delivery.proto' include 'com/example/pizza/pizza.proto' } } Wildcards (with two stars) are also accepted: wire { sourcePath { srcDir 'src/main/protos' include 'com/example/pizza/**' } } You can also do the opposite and exclude some files: wire { sourcePath { srcDir 'src/main/protos' exclude 'com/example/juice/**' exclude 'com/example/pizza/toppings.proto' } } Wire can emit both Java and Kotlin in the same build. Use includes to specify which types are emitted for a target language; subsequent languages will emit what\u2019s left over. wire { ... kotlin { // Kotlin emits the matched types only. includes = [ 'com.example.pizza.*' ] } java { // Java gets everything else! } } Note that sources are specified as file system paths (slash delimiter) and targets are specified as Proto type names (dot delimiter). You may also specify targets with excludes. If you have both includes and excludes, excludes take precedence. wire { ... kotlin { // Kotlin emits everything but sales and geo packages. excludes = [ 'com.example.sales.*' , 'com.example.geo.*' ] } java { // Java gets those because they're left over. } } Wire will print a warning if any name in includes or excludes is unused. When configuring Wire you must use the package name from the .proto file\u2019s package declaration. The option java_package name is not used for Wire configuration. Proto Path for Libraries \u00b6 Large projects may span multiple modules. To support this Wire has a \u2018proto path\u2019. The .proto schema files on this path are used for linking and validation, but they do not yield files in the generated output. The proto path supports the same inputs as the source path: directories, .jar files, and Maven coordinates. Similarly, the proto path may be filtered with include . wire { protoPath { srcDir 'src/main/address-protos' } protoPath { srcJar 'lib/price.jar' } protoPath { srcJar 'com.example:countries:1.0.0' include 'com/example/geo/country.proto' } protoPath { srcDir 'src/main/extra-protos' exclude 'com/example/**' } ... } The source path and proto path are linked together but only types on the source path are generated. Dependencies between Gradle Modules \u00b6 Wire provides support to define dependencies between modules within the same project. A module can include its .proto files into the output resources. Use this when your .jar file can be used as a library for other proto or Wire projects. Note that only the .proto files used in the library will be included. wire { protoLibrary = true } Wire also creates two configurations, protoPath and protoSource you can use to define a dependency on another proto or Wire project. dependencies { // The task `:common-protos:jar` will be added into the dependency // graph of this module for the Wire generating tasks. protoPath ( project ( ':common-protos' )) implementation ( project ( ':common-protos' )) } wire { kotlin { } } Note that protoPath and protoSource dependencies are not transitive by default. If needed, you can change it manually. configurations . protoPath { transitive = true } Pruning \u00b6 For mobile projects it\u2019s easy to generate a lot of unnecessary code. For example, a .proto schema might support types for obsolete features. General-purpose code-shrinking tools like R8 and ProGuard have difficulty shrinking Wire-generated sources because the encode() and decode() functions still use them. Instead, Wire offers its own code shrinker to eliminate unwanted declarations early. Use prune to precisely eliminate an unwanted type or member. These will be eliminated along with all references to them. wire { ... prune 'com.example.store.Store' prune 'com.example.geo.Country' ... } Alternately you may prefer to specify what to keep, pruning everything not reachable from that set. wire { ... root 'com.example.pizza.PizzaDelivery' ... } Version Matching \u00b6 Another way to prune obsolete fields is to assign them a version, then to generate your code against a version range or a unique version. The fields out of the version range will get pruned. Members may be declared with wire.since and wire.until options; enum constant can use wire.constant_since and wire.constant_until . For example, these options declare a field age that was replaced with birth_date in version \u201c5.0\u201d: import \"wire/extensions.proto\" ; message Singer { optional string name = 1 ; optional int32 age = 2 [( wire.until ) = \"5.0\" ]; optional Date birth_date = 3 [( wire.since ) = \"5.0\" ]; } Client code should typically target a single version. In this example, clients will have the name and birth_date fields only. wire { onlyVersion \"5.0\" } Service code that supports many clients should support the union of versions of all supported clients. Such code will have name , as well as both the age and birth_date fields. wire { sinceVersion \"3.0\" untilVersion \"6.0\" } Proto Libraries \u00b6 By default, .proto input files are not included in the generated .jar artifact. Use the protoLibrary option to include them: wire { protoLibrary = true } This is most useful when building .jar files for other wire tasks to use as dependencies. Note that only the true sources are included \u2013 proto messages that are pruned or not used are not included in the output artifact. Customizing Output \u00b6 Java \u00b6 Here\u2019s an exhaustive Java configuration. Booleans are shown with their default behavior. wire { java { // Proto types to include generated sources for. Types listed here will be // generated for this/ target and not for subsequent targets in the task. // // This list should contain package names (suffixed with `.*`) and type names // only. It should not contain member names. includes = [ 'com.example.pizza.*' ] // Proto types to excluded generated sources for. Types listed here will not // be generated for this target. // // This list should contain package names (suffixed with `.*`) and type names // only. It should not contain member names. excludes = [ 'com.example.sales.*' ] // True if types emitted for this target should not also be emitted for other // targets. Use this to cause multiple outputs to be emitted for the same input // type. exclusive = true // Directory to emit to. out \"${buildDir}/custom\" // True for emitted types to implement android.os.Parcelable. android = false // True to enable the androidx.annotation.Nullable annotation where applicable. androidAnnotations = false // True to emit code that uses reflection for reading, writing, and toString // methods which are normally implemented with generated code. compact = false // True to emit types for options declared on messages, fields, etc. emitDeclaredOptions = true , // True to emit annotations for options applied on messages, fields, etc. emitAppliedOptions = false } } Kotlin \u00b6 Here\u2019s an exhaustive Kotlin configuration. Booleans and enums are shown with their default behavior. wire { kotlin { // Proto types to include generated sources for. Types listed here will be // generated for this/ target and not for subsequent targets in the task. // // This list should contain package names (suffixed with `.*`) and type names // only. It should not contain member names. includes = [ 'com.example.pizza.*' ] // Proto types to excluded generated sources for. Types listed here will not // be generated for this target. // // This list should contain package names (suffixed with `.*`) and type names // only. It should not contain member names. excludes = [ 'com.example.sales.*' ] // True if types emitted for this target should not also be emitted for other // targets. Use this to cause multiple outputs to be emitted for the same input // type. exclusive = true // Directory to emit to. out \"${buildDir}/custom\" // True for emitted types to implement android.os.Parcelable. android = false // True for emitted types to implement APIs for easier migration from the Java // target. javaInterop = false // True to emit types for options declared on messages, fields, etc. emitDeclaredOptions = true , // True to emit annotations for options applied on messages, fields, etc. emitAppliedOptions = false , // `suspending` to generate coroutines APIs that require a Kotlin coroutines context. // `blocking` to generate blocking APIs callable by Java and Kotlin. rpcCallStyle = 'blocking' // `client` to generate interfaces best suited to sending outbound calls. // `server` to generate interfaces best suited to receiving inbound calls. // `none` to not generate services. rpcRole = 'server' // If set, the value will be appended to generated service type names. If null, their rpcRole // will be used as a suffix instead. nameSuffix = \"Suffix\" // True for emitted services to implement one interface per RPC. singleMethodServices = false } } Proto \u00b6 Here\u2019s an exhaustive Proto configuration. You can use this target to generate a pruned proto schema, or to pretty-print one. Note that even with multiple outputs set, the proto target will always emit all types, all services, and all extensions of the schema. wire { proto { // Directory to emit to. out \"${buildDir}/custom\" } } Custom Handlers \u00b6 Wire has an unstable API to generate code or other artifacts from a proto schema. You\u2019ll need to implement the CustomHandlerBeta interface. See our MarkdownHandler for a sample implementation. Note that this interface is subject to change. Build that into an jar artifact and add that as a buildscript dependency to your Gradle project. buildscript { dependencies { classpath \"com.example.my-custom-handler:my-custom-handler:1.0.0\" } } Next configure the Wire plugin to call your custom handler. Here\u2019s an exhaustive custom configuration. Booleans and enums are shown with their default behavior. wire { custom { // The name of a Java class to generate code with. This class must: // * be in the buildscript dependencies for this Gradle project // * be a public class // * have a public no-arguments constructor // * implement the com.squareup.wire.schema.CustomHandlerBeta interface customHandlerClass = \"com.example.MyCustomHandler\" // These options work the same as the java and kotlin targets above. includes = [ 'com.example.pizza.*' ] excludes = [ 'com.example.sales.*' ] exclusive = true out \"${buildDir}/custom\" } }","title":"Gradle Plugin"},{"location":"wire_compiler/#wire-compiler-gradle-plugin","text":"Wire has two key components: a compiler that generates Kotlin and Java code at build time, and a runtime library that supports the generated code when your program executes. The compiler is very configurable; this guide explains its features and their use.","title":"Wire Compiler &amp; Gradle Plugin"},{"location":"wire_compiler/#getting-started","text":"The best way to configure and execute the Wire compiler is via our Gradle plugin. It requires Gradle 5.5 or newer. A typical project has .proto files in the standard src/main/proto directory. src/ main/ proto/ com/ example/ pizza/ pizza_delivery.proto pizza.proto sales/ price.proto store.proto geo/ address.proto country.proto kotlin/ com/ example/ pizza/ PizzaApp.kt test/ kotlin/ com/ example/ pizza/ PizzaAppTest.kt build.gradle Because this project uses the default configuration, plugin setup is easy. Just a simple block in build.gradle , Using plugin application: buildscript { repositories { mavenCentral () } dependencies { classpath 'com.squareup.wire:wire-gradle-plugin:<version>' } } apply plugin: 'com.squareup.wire' wire { kotlin {} } Using the plugins DSL: plugins { id 'application' id 'org.jetbrains.kotlin.jvm' id 'com.squareup.wire' } wire { kotlin {} } The plugin will read the .proto schema definitions, validate them, link them, and generate Kotlin code. It uses KotlinPoet internally to generate compact and legible source files. Wire will generate files in build/generated/source/wire . It\u2019ll also register this directory as a source directory for the project so the generated sources are compiled by the Kotlin compiler. Replace kotlin with java to generate Java sources instead.","title":"Getting Started"},{"location":"wire_compiler/#inputs-and-outputs","text":"Wire can pull source .proto schema definitions from a local directory, a local .jar file, or an external artifact specified with Maven coordinates . wire { sourcePath { srcDir 'src/main/protos' } sourcePath { srcJar 'lib/pizza-protos.jar' } sourcePath { srcJar 'com.example.pizza:pizza-protos:1.0.0' } ... } If your resource or directory contains more .proto files than you need to compile you can constrain the inputs to specific files: wire { sourcePath { srcDir 'src/main/protos' include 'com/example/pizza/pizza_delivery.proto' include 'com/example/pizza/pizza.proto' } } Wildcards (with two stars) are also accepted: wire { sourcePath { srcDir 'src/main/protos' include 'com/example/pizza/**' } } You can also do the opposite and exclude some files: wire { sourcePath { srcDir 'src/main/protos' exclude 'com/example/juice/**' exclude 'com/example/pizza/toppings.proto' } } Wire can emit both Java and Kotlin in the same build. Use includes to specify which types are emitted for a target language; subsequent languages will emit what\u2019s left over. wire { ... kotlin { // Kotlin emits the matched types only. includes = [ 'com.example.pizza.*' ] } java { // Java gets everything else! } } Note that sources are specified as file system paths (slash delimiter) and targets are specified as Proto type names (dot delimiter). You may also specify targets with excludes. If you have both includes and excludes, excludes take precedence. wire { ... kotlin { // Kotlin emits everything but sales and geo packages. excludes = [ 'com.example.sales.*' , 'com.example.geo.*' ] } java { // Java gets those because they're left over. } } Wire will print a warning if any name in includes or excludes is unused. When configuring Wire you must use the package name from the .proto file\u2019s package declaration. The option java_package name is not used for Wire configuration.","title":"Inputs and Outputs"},{"location":"wire_compiler/#proto-path-for-libraries","text":"Large projects may span multiple modules. To support this Wire has a \u2018proto path\u2019. The .proto schema files on this path are used for linking and validation, but they do not yield files in the generated output. The proto path supports the same inputs as the source path: directories, .jar files, and Maven coordinates. Similarly, the proto path may be filtered with include . wire { protoPath { srcDir 'src/main/address-protos' } protoPath { srcJar 'lib/price.jar' } protoPath { srcJar 'com.example:countries:1.0.0' include 'com/example/geo/country.proto' } protoPath { srcDir 'src/main/extra-protos' exclude 'com/example/**' } ... } The source path and proto path are linked together but only types on the source path are generated.","title":"Proto Path for Libraries"},{"location":"wire_compiler/#dependencies-between-gradle-modules","text":"Wire provides support to define dependencies between modules within the same project. A module can include its .proto files into the output resources. Use this when your .jar file can be used as a library for other proto or Wire projects. Note that only the .proto files used in the library will be included. wire { protoLibrary = true } Wire also creates two configurations, protoPath and protoSource you can use to define a dependency on another proto or Wire project. dependencies { // The task `:common-protos:jar` will be added into the dependency // graph of this module for the Wire generating tasks. protoPath ( project ( ':common-protos' )) implementation ( project ( ':common-protos' )) } wire { kotlin { } } Note that protoPath and protoSource dependencies are not transitive by default. If needed, you can change it manually. configurations . protoPath { transitive = true }","title":"Dependencies between Gradle Modules"},{"location":"wire_compiler/#pruning","text":"For mobile projects it\u2019s easy to generate a lot of unnecessary code. For example, a .proto schema might support types for obsolete features. General-purpose code-shrinking tools like R8 and ProGuard have difficulty shrinking Wire-generated sources because the encode() and decode() functions still use them. Instead, Wire offers its own code shrinker to eliminate unwanted declarations early. Use prune to precisely eliminate an unwanted type or member. These will be eliminated along with all references to them. wire { ... prune 'com.example.store.Store' prune 'com.example.geo.Country' ... } Alternately you may prefer to specify what to keep, pruning everything not reachable from that set. wire { ... root 'com.example.pizza.PizzaDelivery' ... }","title":"Pruning"},{"location":"wire_compiler/#version-matching","text":"Another way to prune obsolete fields is to assign them a version, then to generate your code against a version range or a unique version. The fields out of the version range will get pruned. Members may be declared with wire.since and wire.until options; enum constant can use wire.constant_since and wire.constant_until . For example, these options declare a field age that was replaced with birth_date in version \u201c5.0\u201d: import \"wire/extensions.proto\" ; message Singer { optional string name = 1 ; optional int32 age = 2 [( wire.until ) = \"5.0\" ]; optional Date birth_date = 3 [( wire.since ) = \"5.0\" ]; } Client code should typically target a single version. In this example, clients will have the name and birth_date fields only. wire { onlyVersion \"5.0\" } Service code that supports many clients should support the union of versions of all supported clients. Such code will have name , as well as both the age and birth_date fields. wire { sinceVersion \"3.0\" untilVersion \"6.0\" }","title":"Version Matching"},{"location":"wire_compiler/#proto-libraries","text":"By default, .proto input files are not included in the generated .jar artifact. Use the protoLibrary option to include them: wire { protoLibrary = true } This is most useful when building .jar files for other wire tasks to use as dependencies. Note that only the true sources are included \u2013 proto messages that are pruned or not used are not included in the output artifact.","title":"Proto Libraries"},{"location":"wire_compiler/#customizing-output","text":"","title":"Customizing Output"},{"location":"wire_compiler/#java","text":"Here\u2019s an exhaustive Java configuration. Booleans are shown with their default behavior. wire { java { // Proto types to include generated sources for. Types listed here will be // generated for this/ target and not for subsequent targets in the task. // // This list should contain package names (suffixed with `.*`) and type names // only. It should not contain member names. includes = [ 'com.example.pizza.*' ] // Proto types to excluded generated sources for. Types listed here will not // be generated for this target. // // This list should contain package names (suffixed with `.*`) and type names // only. It should not contain member names. excludes = [ 'com.example.sales.*' ] // True if types emitted for this target should not also be emitted for other // targets. Use this to cause multiple outputs to be emitted for the same input // type. exclusive = true // Directory to emit to. out \"${buildDir}/custom\" // True for emitted types to implement android.os.Parcelable. android = false // True to enable the androidx.annotation.Nullable annotation where applicable. androidAnnotations = false // True to emit code that uses reflection for reading, writing, and toString // methods which are normally implemented with generated code. compact = false // True to emit types for options declared on messages, fields, etc. emitDeclaredOptions = true , // True to emit annotations for options applied on messages, fields, etc. emitAppliedOptions = false } }","title":"Java"},{"location":"wire_compiler/#kotlin","text":"Here\u2019s an exhaustive Kotlin configuration. Booleans and enums are shown with their default behavior. wire { kotlin { // Proto types to include generated sources for. Types listed here will be // generated for this/ target and not for subsequent targets in the task. // // This list should contain package names (suffixed with `.*`) and type names // only. It should not contain member names. includes = [ 'com.example.pizza.*' ] // Proto types to excluded generated sources for. Types listed here will not // be generated for this target. // // This list should contain package names (suffixed with `.*`) and type names // only. It should not contain member names. excludes = [ 'com.example.sales.*' ] // True if types emitted for this target should not also be emitted for other // targets. Use this to cause multiple outputs to be emitted for the same input // type. exclusive = true // Directory to emit to. out \"${buildDir}/custom\" // True for emitted types to implement android.os.Parcelable. android = false // True for emitted types to implement APIs for easier migration from the Java // target. javaInterop = false // True to emit types for options declared on messages, fields, etc. emitDeclaredOptions = true , // True to emit annotations for options applied on messages, fields, etc. emitAppliedOptions = false , // `suspending` to generate coroutines APIs that require a Kotlin coroutines context. // `blocking` to generate blocking APIs callable by Java and Kotlin. rpcCallStyle = 'blocking' // `client` to generate interfaces best suited to sending outbound calls. // `server` to generate interfaces best suited to receiving inbound calls. // `none` to not generate services. rpcRole = 'server' // If set, the value will be appended to generated service type names. If null, their rpcRole // will be used as a suffix instead. nameSuffix = \"Suffix\" // True for emitted services to implement one interface per RPC. singleMethodServices = false } }","title":"Kotlin"},{"location":"wire_compiler/#proto","text":"Here\u2019s an exhaustive Proto configuration. You can use this target to generate a pruned proto schema, or to pretty-print one. Note that even with multiple outputs set, the proto target will always emit all types, all services, and all extensions of the schema. wire { proto { // Directory to emit to. out \"${buildDir}/custom\" } }","title":"Proto"},{"location":"wire_compiler/#custom-handlers","text":"Wire has an unstable API to generate code or other artifacts from a proto schema. You\u2019ll need to implement the CustomHandlerBeta interface. See our MarkdownHandler for a sample implementation. Note that this interface is subject to change. Build that into an jar artifact and add that as a buildscript dependency to your Gradle project. buildscript { dependencies { classpath \"com.example.my-custom-handler:my-custom-handler:1.0.0\" } } Next configure the Wire plugin to call your custom handler. Here\u2019s an exhaustive custom configuration. Booleans and enums are shown with their default behavior. wire { custom { // The name of a Java class to generate code with. This class must: // * be in the buildscript dependencies for this Gradle project // * be a public class // * have a public no-arguments constructor // * implement the com.squareup.wire.schema.CustomHandlerBeta interface customHandlerClass = \"com.example.MyCustomHandler\" // These options work the same as the java and kotlin targets above. includes = [ 'com.example.pizza.*' ] excludes = [ 'com.example.sales.*' ] exclusive = true out \"${buildDir}/custom\" } }","title":"Custom Handlers"},{"location":"wire_grpc/","text":"Wire gRPC \u00b6 The Wire compiler will generate interfaces for your service RPCs defined in your protobuf schema; under the condition that the target is set to Kotlin. Getting Started \u00b6 You can configure how your services are generated via the Gradle plugin : wire { // Kotlin target will generate code for services. kotlin { // `client` to generate interfaces best suited to sending outbound calls. // `server` to generate interfaces best suited to receiving inbound calls. rpcRole = 'server' // Server only // `suspending` to generate coroutines APIs that require a Kotlin coroutines context. // `blocking` to generate blocking APIs callable by Java and Kotlin. rpcCallStyle = 'suspending' // Server only // True for emitted services to generate one interface per RPC. singleMethodServices = false } } The generated code varies depending on your RPC role, namely client or server. We\u2019ll use the following schema to demonstrate how they differ: syntax = \"proto2\" ; package routeguide ; service RouteGuide { // A simple RPC. rpc GetFeature ( Point ) returns ( Feature ) {} // A server-to-client streaming RPC. rpc ListFeatures ( Rectangle ) returns ( stream Feature ) {} // A client-to-server streaming RPC. rpc RecordRoute ( stream Point ) returns ( RouteSummary ) {} // A Bidirectional streaming RPC. rpc RouteChat ( stream RouteNote ) returns ( stream RouteNote ) {} } gRPC for Clients \u00b6 For the schema RouteGuide , when rpcRole is client , the Wire compiler will generate the following interface: interface RouteGuideClient : Service { fun GetFeature (): GrpcCall < Point , Feature > fun ListFeatures (): GrpcStreamingCall < Rectangle , Feature > fun RecordRoute (): GrpcStreamingCall < Point , RouteSummary > fun RouteChat (): GrpcStreamingCall < RouteNote , RouteNote > } For streaming APIs, we return a GrpcStreamingCall , and a GrpcCall otherwise. With these objects, the caller can communicate with the server. Both blocking and suspending APIs are provided. Wire runtime \u00b6 To help you instantiate your service, we provide a small runtime, namely GrpcClient : val grpcClient = GrpcClient . Builder () . client ( OkHttpClient . Builder (). protocols ( listOf ( Protocol . H2_PRIOR_KNOWLEDGE )). build ()) . baseUrl ( serverUrl ) . build () val routeGuideClient = grpcClient . create ( RouteGuideClient :: class ) gRPC for Servers \u00b6 Blocking APIs \u00b6 Following this configuration: wire { kotlin { rpcRole = 'server' rpcCallStyle = 'blocking' } } the Wire compiler will generate the following interface for the server to implement: interface RouteGuideBlockingServer : Service { fun GetFeature ( request : Point ): Feature fun ListFeatures ( request : Rectangle , response : MessageSink < Feature > ) fun RecordRoute ( request : MessageSource < Point > ): RouteSummary fun RouteChat ( request : MessageSource < RouteNote > , response : MessageSink < RouteNote > ) } For streaming connections, the server can use Wire\u2019s blocking APIs: MessageSource and MessageSink . Suspending APIs \u00b6 Following this configuration: wire { kotlin { rpcRole = 'server' rpcCallStyle = 'suspending' } } the Wire compiler will generate the following interface for the server to implement: interface RouteGuideServer : Service { suspend fun GetFeature ( request : Point ): Feature fun ListFeatures ( request : Rectangle , response : SendChannel < Feature > ) fun RecordRoute ( request : ReceiveChannel < Point > ): RouteSummary fun RouteChat ( request : ReceiveChannel < RouteNote > , response : SendChannel < RouteNote > ) } The server can use Kotlin coroutines\u2019 suspend and Channels mechanisms to execute suspending network calls. Implementing Client Interfaces \u00b6 Wire has helper functions to make it easier to implement its client interfaces. This can be particularly useful for testing. It supports both streaming and non-streaming APIs in Kotlin: class FakeRouteGuideClient : RouteGuideClient { override fun GetFeature (): GrpcCall < Point , Feature > { return GrpcCall { request : Point -> return @GrpcCall Feature ( name = \"test\" , location = request ) } } override fun RouteChat (): GrpcStreamingCall < RouteNote , RouteNote > { return GrpcStreamingCall { requests : ReceiveChannel < RouteNote > , responses : SendChannel < RouteNote > -> try { requests . consumeEach { routeNote : RouteNote -> responses . send ( RouteNote ( message = \"ACK: ${ routeNote . message } \" )) } } finally { responses . close () } } } ... } The GrpcCall and GrpcStreamingCall functions are well suited to expression functions: class FakeRouteGuideClient : RouteGuideClient { override fun GetFeature () = GrpcCall < Point , Feature > { request -> return @GrpcCall Feature ( name = \"test\" , location = request ) } override fun RouteChat () = GrpcStreamingCall < RouteNote , RouteNote > { requests , responses -> try { requests . consumeEach { routeNote -> responses . send ( RouteNote ( message = \"ACK: ${ routeNote . message } \" )) } } finally { responses . close () } } ... } The client interface may also be implemented in Java. Wire only offers a non-streaming helper function. The GrpcStreamingCall above uses coroutines which is Kotlin-only. public class FakeRouteGuideClient implements RouteGuideClient { @Override public GrpcCall < Point , Feature > GetFeature () { return GrpcCalls . grpcCall ( new Function1 < Point , Feature > () { @Override public Feature invoke ( Point request ) { return new Feature . Builder () . name ( \"test\" ) . location ( request ) . build (); } }); } ... } These similarly interact nicely with Java lambdas. Sample \u00b6 Check out our sample project demonstrating bidirectional communication between an Android application and a server. Get it \u00b6 Use Wire runtime Gradle coordinates: implementation ( \"com.squareup.wire:wire-runtime:LATEST_VERSION\" ) In addition, to use Wire gRPC for clients, use these new Gradle coordinates: implementation ( \"com.squareup.wire:wire-grpc-client:LATEST_VERSION\" )","title":"gRPC"},{"location":"wire_grpc/#wire-grpc","text":"The Wire compiler will generate interfaces for your service RPCs defined in your protobuf schema; under the condition that the target is set to Kotlin.","title":"Wire gRPC"},{"location":"wire_grpc/#getting-started","text":"You can configure how your services are generated via the Gradle plugin : wire { // Kotlin target will generate code for services. kotlin { // `client` to generate interfaces best suited to sending outbound calls. // `server` to generate interfaces best suited to receiving inbound calls. rpcRole = 'server' // Server only // `suspending` to generate coroutines APIs that require a Kotlin coroutines context. // `blocking` to generate blocking APIs callable by Java and Kotlin. rpcCallStyle = 'suspending' // Server only // True for emitted services to generate one interface per RPC. singleMethodServices = false } } The generated code varies depending on your RPC role, namely client or server. We\u2019ll use the following schema to demonstrate how they differ: syntax = \"proto2\" ; package routeguide ; service RouteGuide { // A simple RPC. rpc GetFeature ( Point ) returns ( Feature ) {} // A server-to-client streaming RPC. rpc ListFeatures ( Rectangle ) returns ( stream Feature ) {} // A client-to-server streaming RPC. rpc RecordRoute ( stream Point ) returns ( RouteSummary ) {} // A Bidirectional streaming RPC. rpc RouteChat ( stream RouteNote ) returns ( stream RouteNote ) {} }","title":"Getting Started"},{"location":"wire_grpc/#grpc-for-clients","text":"For the schema RouteGuide , when rpcRole is client , the Wire compiler will generate the following interface: interface RouteGuideClient : Service { fun GetFeature (): GrpcCall < Point , Feature > fun ListFeatures (): GrpcStreamingCall < Rectangle , Feature > fun RecordRoute (): GrpcStreamingCall < Point , RouteSummary > fun RouteChat (): GrpcStreamingCall < RouteNote , RouteNote > } For streaming APIs, we return a GrpcStreamingCall , and a GrpcCall otherwise. With these objects, the caller can communicate with the server. Both blocking and suspending APIs are provided.","title":"gRPC for Clients"},{"location":"wire_grpc/#wire-runtime","text":"To help you instantiate your service, we provide a small runtime, namely GrpcClient : val grpcClient = GrpcClient . Builder () . client ( OkHttpClient . Builder (). protocols ( listOf ( Protocol . H2_PRIOR_KNOWLEDGE )). build ()) . baseUrl ( serverUrl ) . build () val routeGuideClient = grpcClient . create ( RouteGuideClient :: class )","title":"Wire runtime"},{"location":"wire_grpc/#grpc-for-servers","text":"","title":"gRPC for Servers"},{"location":"wire_grpc/#blocking-apis","text":"Following this configuration: wire { kotlin { rpcRole = 'server' rpcCallStyle = 'blocking' } } the Wire compiler will generate the following interface for the server to implement: interface RouteGuideBlockingServer : Service { fun GetFeature ( request : Point ): Feature fun ListFeatures ( request : Rectangle , response : MessageSink < Feature > ) fun RecordRoute ( request : MessageSource < Point > ): RouteSummary fun RouteChat ( request : MessageSource < RouteNote > , response : MessageSink < RouteNote > ) } For streaming connections, the server can use Wire\u2019s blocking APIs: MessageSource and MessageSink .","title":"Blocking APIs"},{"location":"wire_grpc/#suspending-apis","text":"Following this configuration: wire { kotlin { rpcRole = 'server' rpcCallStyle = 'suspending' } } the Wire compiler will generate the following interface for the server to implement: interface RouteGuideServer : Service { suspend fun GetFeature ( request : Point ): Feature fun ListFeatures ( request : Rectangle , response : SendChannel < Feature > ) fun RecordRoute ( request : ReceiveChannel < Point > ): RouteSummary fun RouteChat ( request : ReceiveChannel < RouteNote > , response : SendChannel < RouteNote > ) } The server can use Kotlin coroutines\u2019 suspend and Channels mechanisms to execute suspending network calls.","title":"Suspending APIs"},{"location":"wire_grpc/#implementing-client-interfaces","text":"Wire has helper functions to make it easier to implement its client interfaces. This can be particularly useful for testing. It supports both streaming and non-streaming APIs in Kotlin: class FakeRouteGuideClient : RouteGuideClient { override fun GetFeature (): GrpcCall < Point , Feature > { return GrpcCall { request : Point -> return @GrpcCall Feature ( name = \"test\" , location = request ) } } override fun RouteChat (): GrpcStreamingCall < RouteNote , RouteNote > { return GrpcStreamingCall { requests : ReceiveChannel < RouteNote > , responses : SendChannel < RouteNote > -> try { requests . consumeEach { routeNote : RouteNote -> responses . send ( RouteNote ( message = \"ACK: ${ routeNote . message } \" )) } } finally { responses . close () } } } ... } The GrpcCall and GrpcStreamingCall functions are well suited to expression functions: class FakeRouteGuideClient : RouteGuideClient { override fun GetFeature () = GrpcCall < Point , Feature > { request -> return @GrpcCall Feature ( name = \"test\" , location = request ) } override fun RouteChat () = GrpcStreamingCall < RouteNote , RouteNote > { requests , responses -> try { requests . consumeEach { routeNote -> responses . send ( RouteNote ( message = \"ACK: ${ routeNote . message } \" )) } } finally { responses . close () } } ... } The client interface may also be implemented in Java. Wire only offers a non-streaming helper function. The GrpcStreamingCall above uses coroutines which is Kotlin-only. public class FakeRouteGuideClient implements RouteGuideClient { @Override public GrpcCall < Point , Feature > GetFeature () { return GrpcCalls . grpcCall ( new Function1 < Point , Feature > () { @Override public Feature invoke ( Point request ) { return new Feature . Builder () . name ( \"test\" ) . location ( request ) . build (); } }); } ... } These similarly interact nicely with Java lambdas.","title":"Implementing Client Interfaces"},{"location":"wire_grpc/#sample","text":"Check out our sample project demonstrating bidirectional communication between an Android application and a server.","title":"Sample"},{"location":"wire_grpc/#get-it","text":"Use Wire runtime Gradle coordinates: implementation ( \"com.squareup.wire:wire-runtime:LATEST_VERSION\" ) In addition, to use Wire gRPC for clients, use these new Gradle coordinates: implementation ( \"com.squareup.wire:wire-grpc-client:LATEST_VERSION\" )","title":"Get it"},{"location":"wire_json/","text":"Wire JSON \u00b6 Wire offers JSON serialization over Moshi or Gson . We provide an adapter factory for both to configure them to deal with protobuf specifics. Moshi \u00b6 Moshi support is part of the wire-moshi-adapter module. It has to be added to the project dependencies in order to plug the WireJsonAdapterFactory into Moshi. The Maven coordinates are: com.squareup.wire:wire-moshi-adapter:<version> val moshi = Moshi . Builder () . add ( WireJsonAdapterFactory ()) . build () val adapter = moshi . adapter ( Pizza :: class . java ) val pizza : Pizza = ... val json = adapter . toJson ( pizza ) val parsedPizza = adapter . fromJson ( json ) Gson \u00b6 Moshi support is part of the wire-gson-support module. It has to be added to the project dependencies in order to plug the WireTypeAdapterFactory into Gson. The Maven coordinates are: com.squareup.wire:wire-gson-support:<version> val gson = GsonBuilder () . registerTypeAdapterFactory ( WireTypeAdapterFactory ()) . create () val adapter = gson . adapter ( Pizza :: class . java ) val pizza : Pizza = ... val json = adapter . toJson ( pizza ) val parsedPizza = adapter . fromJson ( json ) Protoc \u00b6 Wire is interoperable with protoc for all proto3 messages. The JSON representation of proto2 is unspecified. JSON representations of proto2 messages from Wire and protoc are not interoperable. Note that by default Protoc throws an error for unknown fields. Wire will ignore them.","title":"JSON"},{"location":"wire_json/#wire-json","text":"Wire offers JSON serialization over Moshi or Gson . We provide an adapter factory for both to configure them to deal with protobuf specifics.","title":"Wire JSON"},{"location":"wire_json/#moshi","text":"Moshi support is part of the wire-moshi-adapter module. It has to be added to the project dependencies in order to plug the WireJsonAdapterFactory into Moshi. The Maven coordinates are: com.squareup.wire:wire-moshi-adapter:<version> val moshi = Moshi . Builder () . add ( WireJsonAdapterFactory ()) . build () val adapter = moshi . adapter ( Pizza :: class . java ) val pizza : Pizza = ... val json = adapter . toJson ( pizza ) val parsedPizza = adapter . fromJson ( json )","title":"Moshi"},{"location":"wire_json/#gson","text":"Moshi support is part of the wire-gson-support module. It has to be added to the project dependencies in order to plug the WireTypeAdapterFactory into Gson. The Maven coordinates are: com.squareup.wire:wire-gson-support:<version> val gson = GsonBuilder () . registerTypeAdapterFactory ( WireTypeAdapterFactory ()) . create () val adapter = gson . adapter ( Pizza :: class . java ) val pizza : Pizza = ... val json = adapter . toJson ( pizza ) val parsedPizza = adapter . fromJson ( json )","title":"Gson"},{"location":"wire_json/#protoc","text":"Wire is interoperable with protoc for all proto3 messages. The JSON representation of proto2 is unspecified. JSON representations of proto2 messages from Wire and protoc are not interoperable. Note that by default Protoc throws an error for unknown fields. Wire will ignore them.","title":"Protoc"},{"location":"wire_vs_protoc/","text":"Wire versus Protoc \u00b6 Non-Primitive Types \u00b6 Protoc generates literal equivalents for all the Proto3 new types like empty , struct , etc. Wire tries to reuse existing types in the corresponding language when possible. The only new type Wire brings is AnyMessage for the google.protobuf.Any proto type. Any \u00b6 The Any type wraps an arbitrary protobuf message by holding a field to identify its type and another field for storing the serialized representation of the wrapped message. Wire comes with its own AnyMessage type to represent google.protobuf.Any . class AnyMessage ( val typeUrl : String , val value : okio . ByteString ) It comes with a few methods to wrap or unwrap the embedded message. // Wire val anyMessage : AnyMessage = AnyMessage . pack ( person ) val person : Person = anyMessage . unpack ( Person . ADAPTER ) // Protoc val any : Any = Any . pack ( foo ) val person : Person = any . unpack ( Person . class ) Duration & Timestamp \u00b6 Both google.protobuf.Duration and google.protobuf.Timestamp types will be generated by using their JVM equivalent: java.time.Duration and java.time.Instant . For non-JVM platforms, we provide two new Wire types with the same APIs: class com . squareup . wire . Duration { fun getSeconds (): Long fun getNano (): Int } fun durationOfSeconds ( seconds : Long , nano : Long ): Duration class com . squareup . wire . Instant { fun getEpochSecond (): Long fun getNano (): Int } fun ofEpochSecond ( epochSecond : Long , nano : Long ): Instant // Wire val duration : java . time . Duration = Duration . standardMinutes ( 15 ) val instant : java . time . Instant = Instant . now () // Protoc val duration : google . protobuf . Duration = Duration . newBuilder () . setSeconds ( 60 * 15 ) . build () val instant : google . protobuf . Timestamp = Timestamps . fromMillis ( System . currentTimeMillis ()) Struct \u00b6 google.protobuf.Struct is meant mainly to represent JSON objects in code. Instead of building new types, Wire reuses Java/Kotlin native types to represent all Struct types. Google Protobuf Type Wire\u2019s Java Equivalent Wire\u2019s Kotlin Equivalent Struct Map<String, ?> Map<String, ?>? ListValue List<?> List<?>? Value Object Any? NullValue Void Nothing? One difference worth noting between Protoc and Wire is that Protoc can make the difference between an absent value, and a null value, Wire doesn\u2019t. Wire will always write null s in JSON objects except at the root of it. // Wire val struct = mapOf ( \"a\" to 1.0 ) val list = listOf ( \u201c b \u201d , 2.0 ) val boolValue = true val nullValue = null // Protoc val struct : Struct = Struct . newBuilder (). apply { putFields ( \u201c a \u201d , Value . newBuilder . setNumberValue ( 1.0 ). build ()) } . build () val list : List = ListValue . newBuilder (). apply { addValues ( Value . newBuilder . setStringValue ( \u201c a \u201d ). build ()) addValues ( Value . newBuilder . setNumberValue ( 2.0 ). build ()) } . build () val boolValue = Value . newBuilder . setBoolValue ( true ). build () val nullValue = Value . newBuilder (). setNullValue ( NullValue . NULL_VALUE ). build () Wrappers \u00b6 Wire didn\u2019t create new types for wrappers either, each wrapper will be represented by a nullable version of the primitive type it defines. For instance google.protobuf.FloatValue will be represented in Java by the float boxed type @Nullable Float , in Kotlin by Float? . // Wire val floatValue = 33.3f // Protoc val floatValue = FloatValue . newBuilder (). setValue ( 33.3f ). build () JSON \u00b6 While Proto2 didn\u2019t, Proto3 defines Protobuf serialization over JSON. Wire and Protoc are interoperable but their API are quite different. Wire offers JSON serialization over Moshi or Gson . Protoc brings its own JsonFormatter. Beware that Protoc throws an error for unknown fields, you need to configure it to opt-out of this behavior! // Wire & Moshi val moshi = Moshi . Builder () . add ( WireJsonAdapterFactory ()) . build () val adapter = moshi . adapter ( Pizza :: class . java ) val pizza : Pizza = ... val json = adapter . toJson ( pizza ) val parsedPizza = adapter . fromJson ( json ) // Protoc val pizza : PizzaOuterClass . Pizza = \u2026 val json = JsonFormat . printer (). print ( value ) val jsonParser = JsonFormat . parser (). ignoringUnknownFields () val parsedBuilder = PizzaOuterClass . Pizza . newBuilder () jsonParser . merge ( json , parsedBuilder ) val parsedPizza = parsedBuilder . build ()","title":"Wire vs Protoc"},{"location":"wire_vs_protoc/#wire-versus-protoc","text":"","title":"Wire versus Protoc"},{"location":"wire_vs_protoc/#non-primitive-types","text":"Protoc generates literal equivalents for all the Proto3 new types like empty , struct , etc. Wire tries to reuse existing types in the corresponding language when possible. The only new type Wire brings is AnyMessage for the google.protobuf.Any proto type.","title":"Non-Primitive Types"},{"location":"wire_vs_protoc/#any","text":"The Any type wraps an arbitrary protobuf message by holding a field to identify its type and another field for storing the serialized representation of the wrapped message. Wire comes with its own AnyMessage type to represent google.protobuf.Any . class AnyMessage ( val typeUrl : String , val value : okio . ByteString ) It comes with a few methods to wrap or unwrap the embedded message. // Wire val anyMessage : AnyMessage = AnyMessage . pack ( person ) val person : Person = anyMessage . unpack ( Person . ADAPTER ) // Protoc val any : Any = Any . pack ( foo ) val person : Person = any . unpack ( Person . class )","title":"Any"},{"location":"wire_vs_protoc/#duration-timestamp","text":"Both google.protobuf.Duration and google.protobuf.Timestamp types will be generated by using their JVM equivalent: java.time.Duration and java.time.Instant . For non-JVM platforms, we provide two new Wire types with the same APIs: class com . squareup . wire . Duration { fun getSeconds (): Long fun getNano (): Int } fun durationOfSeconds ( seconds : Long , nano : Long ): Duration class com . squareup . wire . Instant { fun getEpochSecond (): Long fun getNano (): Int } fun ofEpochSecond ( epochSecond : Long , nano : Long ): Instant // Wire val duration : java . time . Duration = Duration . standardMinutes ( 15 ) val instant : java . time . Instant = Instant . now () // Protoc val duration : google . protobuf . Duration = Duration . newBuilder () . setSeconds ( 60 * 15 ) . build () val instant : google . protobuf . Timestamp = Timestamps . fromMillis ( System . currentTimeMillis ())","title":"Duration &amp; Timestamp"},{"location":"wire_vs_protoc/#struct","text":"google.protobuf.Struct is meant mainly to represent JSON objects in code. Instead of building new types, Wire reuses Java/Kotlin native types to represent all Struct types. Google Protobuf Type Wire\u2019s Java Equivalent Wire\u2019s Kotlin Equivalent Struct Map<String, ?> Map<String, ?>? ListValue List<?> List<?>? Value Object Any? NullValue Void Nothing? One difference worth noting between Protoc and Wire is that Protoc can make the difference between an absent value, and a null value, Wire doesn\u2019t. Wire will always write null s in JSON objects except at the root of it. // Wire val struct = mapOf ( \"a\" to 1.0 ) val list = listOf ( \u201c b \u201d , 2.0 ) val boolValue = true val nullValue = null // Protoc val struct : Struct = Struct . newBuilder (). apply { putFields ( \u201c a \u201d , Value . newBuilder . setNumberValue ( 1.0 ). build ()) } . build () val list : List = ListValue . newBuilder (). apply { addValues ( Value . newBuilder . setStringValue ( \u201c a \u201d ). build ()) addValues ( Value . newBuilder . setNumberValue ( 2.0 ). build ()) } . build () val boolValue = Value . newBuilder . setBoolValue ( true ). build () val nullValue = Value . newBuilder (). setNullValue ( NullValue . NULL_VALUE ). build ()","title":"Struct"},{"location":"wire_vs_protoc/#wrappers","text":"Wire didn\u2019t create new types for wrappers either, each wrapper will be represented by a nullable version of the primitive type it defines. For instance google.protobuf.FloatValue will be represented in Java by the float boxed type @Nullable Float , in Kotlin by Float? . // Wire val floatValue = 33.3f // Protoc val floatValue = FloatValue . newBuilder (). setValue ( 33.3f ). build ()","title":"Wrappers"},{"location":"wire_vs_protoc/#json","text":"While Proto2 didn\u2019t, Proto3 defines Protobuf serialization over JSON. Wire and Protoc are interoperable but their API are quite different. Wire offers JSON serialization over Moshi or Gson . Protoc brings its own JsonFormatter. Beware that Protoc throws an error for unknown fields, you need to configure it to opt-out of this behavior! // Wire & Moshi val moshi = Moshi . Builder () . add ( WireJsonAdapterFactory ()) . build () val adapter = moshi . adapter ( Pizza :: class . java ) val pizza : Pizza = ... val json = adapter . toJson ( pizza ) val parsedPizza = adapter . fromJson ( json ) // Protoc val pizza : PizzaOuterClass . Pizza = \u2026 val json = JsonFormat . printer (). print ( value ) val jsonParser = JsonFormat . parser (). ignoringUnknownFields () val parsedBuilder = PizzaOuterClass . Pizza . newBuilder () jsonParser . merge ( json , parsedBuilder ) val parsedPizza = parsedBuilder . build ()","title":"JSON"}]}